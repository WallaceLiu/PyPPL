<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>API - PyPPL</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "API";
    var mkdocs_page_input_path = "api.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> PyPPL</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Introduction</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../basic-concepts-and-directory-structure/">Basics and folder structure</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../placeholders/">Templating</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../channels/">Channels</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../specify-input-and-output-of-a-process/">Input and output of a process</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../write-your-script/">The heart: script</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../export-output-files/">Output file exporting</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../caching/">Caching and resuming processes</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../runners/">Runners and running profiles</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../error-handling/">Error handling of processes</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../set-other-properties-of-a-process/">Other attributes of a process</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../configure-your-logs/">Log configuration</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../draw-flowchart-of-a-pipeline/">Pipeline flowchart</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../configure-a-pipeline/">Pipeline configuration</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../command-line-argument-parser/">Command line argument parser</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../aggregations/">Aggregations</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../command-line-tool/">Command line tool</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">API</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#module-pyppl">module: pyppl</a></li>
    

    <li class="toctree-l2"><a href="#dry-runner">Dry runner</a></li>
    

    <li class="toctree-l2"><a href="#a-runner-wrapper-for-a-single-script">A runner wrapper for a single script</a></li>
    

    <li class="toctree-l2"><a href="#author-pwwangpwwangcom">Author: pwwang@pwwang.com</a></li>
    

    <li class="toctree-l2"><a href="#examples">Examples:</a></li>
    

    <li class="toctree-l2"><a href="#see-runnerunittestpy">@see runner.unittest.py</a></li>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../faq/">FAQ</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../change-log/">Change log</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">PyPPL</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>API</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="module-pyppl">module: pyppl</h2>
<p>!!! hint class: <code>PyPPL</code></p>
<pre><code>The PyPPL class

- **static variables:**  
`TIPS`: The tips for users  
`RUNNERS`: Registered runners  
`DEFAULT_CFGFILES`: Default configuration file  
      - method: `__init__ (self, config, cfgfile)`


    Constructor  
    - **params:**  
    `config`: the configurations for the pipeline, default: {}  
    `cfgfile`:  the configuration file for the pipeline, default: `~/.PyPPL.json` or `./.PyPPL`  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - staticmethod: `_any2procs (*args)`


    Get procs from anything (aggr.starts, proc, procs, proc names)  
    - **params:**  
    `arg`: anything  
    - **returns:**  
    A set of procs  
          - staticmethod: `_checkProc (proc)`


    Check processes, whether 2 processes have the same id and tag  
    - **params:**  
    `proc`: The process  
    - **returns:**  
    If there are 2 processes with the same id and tag, raise `ValueError`.  
          - staticmethod: `_registerProc (proc)`


    Register the process  
    - **params:**  
    `proc`: The process  
          - method: `_resume (self, *args, **kwargs)`


    Mark processes as to be resumed  
    - **params:**  
    `args`: the processes to be marked. The last element is the mark for processes to be skipped.  
          - method: `flowchart (self, fcfile, dotfile)`


    Generate graph in dot language and visualize it.  
    - **params:**  
    `dotfile`: Where to same the dot graph. Default: `None` (`path.splitext(sys.argv[0])[0] + ".pyppl.dot"`)  
    `fcfile`:  The flowchart file. Default: `None` (`path.splitext(sys.argv[0])[0] + ".pyppl.svg"`)  
    - For example: run `python pipeline.py` will save it to `pipeline.pyppl.svg`  
    `dot`:     The dot visulizer. Default: "dot -Tsvg {{dotfile}} &gt; {{fcfile}}"  
    - **returns:**  
    The pipeline object itself.  
          - staticmethod: `registerRunner (runner)`


    Register a runner  
    - **params:**  
    `runner`: The runner to be registered.  
          - method: `resume (self, *args)`


    Mark processes as to be resumed  
    - **params:**  
    `args`: the processes to be marked  
    - **returns:**  
    The pipeline object itself.  
          - method: `resume2 (self, *args)`


    Mark processes as to be resumed  
    - **params:**  
    `args`: the processes to be marked  
    - **returns:**  
    The pipeline object itself.  
          - method: `run (self, profile)`


    Run the pipeline  
    - **params:**  
    `profile`: the profile used to run, if not found, it'll be used as runner name. default: 'default'  
    - **returns:**  
    The pipeline object itself.  
          - method: `showAllRoutes (self)`

          - method: `start (self, *args)`


    Set the starting processes of the pipeline  
    - **params:**  
    `args`: the starting processes  
    - **returns:**  
    The pipeline object itself.  
      !!! hint class: `Proc`


The Proc class defining a process

- **static variables:**  
`RUNNERS`:       The regiested runners  
`ALIAS`:         The alias for the properties  
`LOG_NLINE`:     The limit of lines of logging information of same type of messages

- **magic methods:**  
`__getattr__(self, name)`: get the value of a property in `self.props`  
`__setattr__(self, name, value)`: set the value of a property in `self.config`  
      - method: `__getattr__ (self, name)`

          - method: `__init__ (self, tag, desc, id, **kwargs)`


    Constructor  
    - **params:**  
    `tag`:  The tag of the process  
    `desc`: The description of the process  
    `id`:   The identify of the process  
    - **config:**  
    id, input, output, ppldir, forks, cache, cclean, rc, echo, runner, script, depends, tag, desc, dirsig  
    exdir, exhow, exow, errhow, errntry, lang, beforeCmd, afterCmd, workdir, args, aggr  
    callfront, callback, expect, expart, template, tplenvs, resume, nthread  
    - **props**  
    input, output, rc, echo, script, depends, beforeCmd, afterCmd, workdir, expect  
    expart, template, channel, jobs, ncjobids, size, sets, procvars, suffix, logs  
          - method: `__repr__ (self)`

          - method: `__setattr__ (self, name, value)`

          - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_buildInput (self)`


    Build the input data  
    Input could be:  
    1. list: ['input', 'infile:file'] &lt;=&gt; ['input:var', 'infile:path']  
    2. str : "input, infile:file" &lt;=&gt; input:var, infile:path  
    3. dict: {"input": channel1, "infile:file": channel2}  
    or    {"input:var, input:file" : channel3}  
    for 1,2 channels will be the combined channel from dependents, if there is not dependents, it will be sys.argv[1:]  
          - method: `_buildJobs (self)`


    Build the jobs.  
          - method: `_buildOutput (self)`


    Build the output data templates waiting to be rendered.  
          - method: `_buildProcVars (self)`


    Build proc attribute values for template rendering,  
    and also echo some out.  
          - method: `_buildProps (self)`


    Compute some properties  
          - method: `_buildScript (self)`


    Build the script template waiting to be rendered.  
          - method: `_checkCached (self)`


    Tell whether the jobs are cached  
    - **returns:**  
    True if all jobs are cached, otherwise False  
          - method: `_readConfig (self, profile, profiles)`


    Read the configuration  
    - **params:**  
    `config`: The configuration  
          - method: `_runCmd (self, key)`


    Run the `beforeCmd` or `afterCmd`  
    - **params:**  
    `key`: "beforeCmd" or "afterCmd"  
    - **returns:**  
    The return code of the command  
          - method: `_runJobs (self)`


    Submit and run the jobs  
          - method: `_saveSettings (self)`


    Save all settings in proc.settings, mostly for debug  
          - method: `_suffix (self)`


    Calcuate a uid for the process according to the configuration  
    The philosophy:  
    1. procs from different script must have different suffix (sys.argv[0])  
    2. procs from the same script:  
    - procs with different id or tag have different suffix  
    - procs with different input have different suffix (depends, input)  
    - **returns:**  
    The uniq id of the process  
          - method: `_tidyAfterRun (self)`


    Do some cleaning after running jobs  
    self.resume can only be:  
    - '': normal process  
    - skip+: skipped process but required workdir and data exists  
    - resume: resume pipeline from this process, no requirement  
    - resume+: get data from workdir/proc.settings, and resume  
          - method: `_tidyBeforeRun (self)`


    Do some preparation before running jobs  
          - method: `copy (self, tag, desc, id)`


    Copy a process  
    - **params:**  
    `id`: The new id of the process, default: `None` (use the varname)  
    `tag`:   The tag of the new process, default: `None` (used the old one)  
    `desc`:  The desc of the new process, default: `None` (used the old one)  
    - **returns:**  
    The new process  
          - method: `log (self, msg, level, key)`


    The log function with aggregation name, process id and tag integrated.  
    - **params:**  
    `msg`:   The message to log  
    `level`: The log level  
    `key`:   The type of messages  
          - method: `name (self, aggr)`


    Get my name include `aggr`, `id`, `tag`  
    - **returns:**  
    the name  
          - method: `run (self, profile, profiles)`


    Run the jobs with a configuration  
    - **params:**  
    `config`: The configuration  
      # module: pyppl.aggr
</code></pre>
<p>The aggregation of procs<br />
  !!! hint class: <code>_Proxy</code></p>
<pre><code>A proxy for a list of procs to set/get their attributes  
      - method: `__getattr__ (self, name)`

          - method: `__getitem__ (self, name)`

          - method: `__init__ (self, aggr, procs, prefix, check)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ (self, name, value)`

          - method: `__setitem__ (self, name, value)`

          - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `AggrAttributeError`


Raise when there is an error to set/get Aggr attributes  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, key, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `Aggr`


The aggregation of a set of processes

- **magic methods:**  
`__setattr__(self, name, value)`: Set property value of an aggregation.  
- if it's a common property, set it to all processes  
- if it is `input` set it to starting processes  
- if it is `depends` set it to the end processes  
- if it is related to `export` (startswith `ex`), set it to the end processes  
- if it is in ['starts', 'ends', 'id'], set it to the aggregation itself.  
- Otherwise a `ValueError` raised.  
- You can use `[aggr].[proc].[prop]` to set/get the properties of a processes in the aggregation.

      - method: `__getattr__ (self, name)`

          - method: `__getitem__ (self, key)`


    Select processes  
    ```  
    # self._procs = OrderedDict([  
    #   ('a', Proc(id = 'a')),  
    #   ('b', Proc(id = 'b')),  
    #   ('c', Proc(id = 'c')),  
    #   ('d', Proc(id = 'd'))  
    # ])  
      
    self['a'] # proc a  
    self[0]   # proc a  
    self[1:2] # _Proxy of (proc b, proc c)  
    self[1,3] # _Proxy of (proc b, proc d)  
    self['b', 'c'] # _Proxy of (proc b, proc c)  
    self['b,c'] # _Proxy of (proc b, proc c)  
    self[Proc(id = 'd')] # proc d  
    ```  
          - method: `__init__ (self, *args, **kwargs)`


    Constructor  
    - **params:**  
    `args`: the set of processes  
    `depends`: Whether auto deduce depends. Default: True  
    `id`: The id of the aggr. Default: None (the variable name)  
    `tag`: The tag of the processes. Default: None (a unique 4-char str according to the id)  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ (self, name, value)`

          - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_select (self, key, forceList, flatten)`


    Select processes  
    ```  
    # self._procs = OrderedDict([  
    #   ('a', Proc(id = 'a')),  
    #   ('b', Proc(id = 'b')),  
    #   ('c', Proc(id = 'c')),  
    #   ('d', Proc(id = 'd'))  
    # ])

    self['a'] # proc a  
    self[0]   # proc a  
    self[1:2] # _Proxy of (proc b, proc c)  
    self[1,3] # _Proxy of (proc b, proc d)  
    self['b', 'c'] # _Proxy of (proc b, proc c)  
    self['b,c'] # _Proxy of (proc b, proc c)  
    self[Proc(id = 'd')] # proc d  
          - method: `addEnd (self, *procs)`


    Add end processes  
    - **params:**  
    `procs`: The selector of processes to add  
          - method: `addProc (self, p, tag, where, copy)`


    Add a process to the aggregation.  
    Note that you have to adjust the dependencies after you add processes.  
    - **params:**  
    `p`:     The process  
    `where`: Add to where: 'starts', 'ends', 'both' or None (default)  
    - **returns:**  
    the aggregation itself  
          - method: `addStart (self, *procs)`


    Add start processes  
    - **params:**  
    `procs`: The selector of processes to add  
          - method: `copy (self, tag, depends, id, delegates, modules)`


    Like `proc`'s `copy` function, copy an aggregation. Each processes will be copied.  
    - **params:**  
    `tag`:      The new tag of all copied processes  
    `depends`: Whether to copy the dependencies or not. Default: True  
    - dependences for processes in starts will not be copied  
    `id`:    Use a different id if you don't want to use the variant name  
    `delegates`: Copy delegates? Default: `True`  
    `configs`: Copy configs? Default: `True`  
    - **returns:**  
    The new aggregation  
          - method: `delEnd (self, *procs)`


    Delete end processes  
    - **params:**  
    `procs`: The selector of processes to delete  
          - method: `delStart (self, *procs)`


    Delete start processes  
    - **params:**  
    `procs`: The selector of processes to delete  
          - method: `delegate (self, attrs, procs)`


    Delegate the procs to have the attributes set by:  
    `aggr.args.a.b = 1`  
    Instead of setting `args.a.b` of all processes, `args.a.b` of only delegated processes will be set.  
    `procs` can be `starts`/`ends`, but it cannot be set with other procs, which means you can do:  
    `aggr.delegate('args', 'starts')`, but not `aggr.delegate('args', ['starts', 'pXXX'])`  
          - method: `module (self, name, starts, depends, ends, starts_shared, depends_shared, ends_shared)`


    Define a function for aggr.  
    The "shared" parameters will be indicators not to remove those processes  
    when the shared function is on.  
    - **params:**  
    `name`          : The name of the function  
    `starts`        : A list of start processes.  
    `depends`       : A dict of dependences of the procs  
    `ends`          : A list of end processes  
    `starts_shared` : A dict of functions that shares the same starts  
    `depends_shared`: A dict of functions that shares the same depends  
    `ends_shared`   : A dict of functions that shares the same ends  
    - For example: `{&lt;procs&gt;: &lt;func&gt;}`  
          - method: `moduleFunc (self, name, on, off)`


    Define modules using functions  
    - **params:**  
    `name`: The name of the module  
    `on`  : The function when the module is turned on  
    `off` : The function when the module is turned off  
          - method: `off (self, *names)`


    Turn off modules  
    - **params:**  
    `names`: The names of the modules.  
          - method: `on (self, *names)`


    Turn on modules  
    - **params:**  
    `names`: The names of the modules.  
      !!! hint class: `AggrKeyError`


Raise when error occurred doing aggr[...]  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, key, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `AggrCopyError`


Raise when there is an error to set/get Aggr attributes  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, key, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  # module: pyppl.channel
</code></pre>
<p>Channel for pyppl<br />
  !!! hint function: <code>glob (pathname)</code></p>
<pre><code>Return a list of paths matching a pathname pattern.

The pattern may contain simple shell-style wildcards a la  
fnmatch. However, unlike fnmatch, filenames starting with a  
dot are special cases that are not matched by '*' and '?'  
patterns.

  !!! hint class: `Channel`


The channen class, extended from `list`  
      - method: `__add__ ()`

    x.__add__(y) &lt;==&gt; x+y      - method: `__contains__ ()`

    x.__contains__(y) &lt;==&gt; y in x      - method: `__delitem__ ()`

    x.__delitem__(y) &lt;==&gt; del x[y]      - method: `__delslice__ ()`

    x.__delslice__(i, j) &lt;==&gt; del x[i:j]

    Use of negative indices is not supported.      - method: `__ge__ ()`

    x.__ge__(y) &lt;==&gt; x&gt;=y      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__gt__ ()`

    x.__gt__(y) &lt;==&gt; x&gt;y      - method: `__iadd__ ()`

    x.__iadd__(y) &lt;==&gt; x+=y      - method: `__imul__ ()`

    x.__imul__(y) &lt;==&gt; x*=y      - method: `__init__ ()`

    x.__init__(...) initializes x; see help(type(x)) for signature      - method: `__iter__ ()`

    x.__iter__() &lt;==&gt; iter(x)      - method: `__le__ ()`

    x.__le__(y) &lt;==&gt; x&lt;=y      - method: `__len__ ()`

    x.__len__() &lt;==&gt; len(x)      - method: `__lt__ ()`

    x.__lt__(y) &lt;==&gt; x&lt;y      - method: `__mul__ ()`

    x.__mul__(n) &lt;==&gt; x*n      - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__reversed__ ()`

    L.__reversed__() -- return a reverse iterator over the list      - method: `__rmul__ ()`

    x.__rmul__(n) &lt;==&gt; n*x      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__setitem__ ()`

    x.__setitem__(i, y) &lt;==&gt; x[i]=y      - method: `__setslice__ ()`

    x.__setslice__(i, j, y) &lt;==&gt; x[i:j]=y

    Use  of negative indices is not supported.      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - staticmethod: `_tuplize (tu)`


    A private method, try to convert an element to tuple  
    If it's a string, convert it to `(tu, )`  
    Else if it is iterable, convert it to `tuple(tu)`  
    Otherwise, convert it to `(tu, )`  
    Notice that string is also iterable.  
    - **params:**  
    `tu`: the element to be converted  
    - **returns:**  
    The converted element  
          - method: `append ()`

    L.append(object) -- append object to end      - method: `attach (self, *names, **kwargs)`


    Attach columns to names of Channel, so we can access each column by:  
    `ch.col0` == ch.colAt(0)  
    - **params:**  
    `names`: The names. Have to be as length as channel's width. None of them should be Channel's property name  
    `flatten`: Whether flatten the channel for the name being attached  
          - method: `cbind (self, *cols)`


    Add columns to the channel  
    - **params:**  
    `cols`: The columns  
    - **returns:**  
    The channel with the columns inserted.  
          - method: `colAt (self, index)`


    Fetch one column of a Channel  
    - **params:**  
    `index`: which column to fetch  
    - **returns:**  
    The Channel with that column  
          - method: `collapse (self, col)`


    Do the reverse of expand  
    length: N -&gt; 1  
    width:  M -&gt; M  
    - **params:**  
    `col`:     the index of the column used to collapse  
    - **returns:**  
    The collapsed Channel  
          - method: `copy (self)`


    Copy a Channel using `copy.copy`  
    - **returns:**  
    The copied Channel  
          - method: `count ()`

    L.count(value) -&gt; integer -- return number of occurrences of value      - staticmethod: `create (l)`


    Create a Channel from a list  
    - **params:**  
    `l`: The list, default: []  
    - **returns:**  
    The Channel created from the list  
          - method: `expand (self, col, pattern, t, sortby, reverse)`


    expand the Channel according to the files in &lt;col&gt;, other cols will keep the same  
    `[(dir1/dir2, 1)].expand (0, "*")` will expand to  
    `[(dir1/dir2/file1, 1), (dir1/dir2/file2, 1), ...]`  
    length: 1 -&gt; N  
    width:  M -&gt; M  
    - **params:**  
    `col`:     the index of the column used to expand  
    `pattern`: use a pattern to filter the files/dirs, default: `*`  
    `t`:       the type of the files/dirs to include  
    - 'dir', 'file', 'link' or 'any' (default)  
    `sortby`:  how the list is sorted  
    - 'name' (default), 'mtime', 'size'  
    `reverse`: reverse sort. Default: False  
    - **returns:**  
    The expanded Channel  
          - method: `extend ()`

    L.extend(iterable) -- extend list by appending elements from the iterable      - method: `filter (self, func)`


    Alias of python builtin `filter`  
    - **params:**  
    `func`: the function. Default: None  
    - **returns:**  
    The filtered Channel  
          - method: `filterCol (self, func, col)`


    Just filter on the first column  
    - **params:**  
    `func`: the function  
    `col`: the column to filter  
    - **returns:**  
    The filtered Channel  
          - method: `flatten (self, col)`


    Convert a single-column Channel to a list (remove the tuple signs)  
    `[(a,), (b,)]` to `[a, b]`  
    - **params:**  
    `col`: The column to flat. None for all columns (default)  
    - **returns:**  
    The list converted from the Channel.  
          - method: `fold (self, n)`


    Fold a Channel. Make a row to n-length chunk rows  
    ```  
    a1  a2  a3  a4  
    b1  b2  b3  b4  
    if n==2, fold(2) will change it to:  
    a1  a2  
    a3  a4  
    b1  b2  
    b3  b4  
    ```  
    - **params:**  
    `n`: the size of the chunk  
    - **returns**  
    The new Channel  
          - staticmethod: `fromArgv ()`


    Create a Channel from `sys.argv[1:]`  
    "python test.py a b c" creates a width=1 Channel  
    "python test.py a,1 b,2 c,3" creates a width=2 Channel  
    - **returns:**  
    The Channel created from the command line arguments  
          - staticmethod: `fromChannels (*args)`


    Create a Channel from Channels  
    - **params:**  
    `args`: The Channels  
    - **returns:**  
    The Channel merged from other Channels  
          - staticmethod: `fromFile (fn, header, skip, delimit)`


    Create Channel from the file content  
    It's like a matrix file, each row is a row for a Channel.  
    And each column is a column for a Channel.  
    - **params:**  
    `fn`:      the file  
    `header`:  Whether the file contains header. If True, will attach the header  
    - So you can use `channel.&lt;header&gt;` to fetch the column  
    `skip`:    first lines to skip  
    `delimit`: the delimit for columns  
    - **returns:**  
    A Channel created from the file  
          - staticmethod: `fromPairs (pattern)`


    Create a width = 2 Channel from a pattern  
    - **params:**  
    `pattern`: the pattern  
    - **returns:**  
    The Channel create from every 2 files match the pattern  
          - staticmethod: `fromParams (*pnames)`


    Create a Channel from params  
    - **params:**  
    `*pnames`: The names of the option  
    - **returns:**  
    The Channel  
          - staticmethod: `fromPattern (pattern, t, sortby, reverse)`


    Create a Channel from a path pattern  
    - **params:**  
    `pattern`: the pattern with wild cards  
    `t`:       the type of the files/dirs to include  
    - 'dir', 'file', 'link' or 'any' (default)  
    `sortby`:  how the list is sorted  
    - 'name' (default), 'mtime', 'size'  
    `reverse`: reverse sort. Default: False  
    - **returns:**  
    The Channel created from the path  
          - method: `get (self, idx)`


    Get the element of a flattened channel  
    - **params:**  
    `idx`: The index of the element to get. Default: 0  
    - **return:**  
    The element  
          - method: `index ()`

    L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.  
    Raises ValueError if the value is not present.      - method: `insert (self, cidx, *cols)`


    Insert columns to a channel  
    - **params:**  
    `cidx`: Insert into which index of column?  
    `cols`: the columns to be bound to Channel  
    - **returns:**  
    The combined Channel  
    Note, self is also changed  
          - method: `length (self)`


    Get the length of a Channel  
    It's just an alias of `len(chan)`  
    - **returns:**  
    The length of the Channel  
          - method: `map (self, func)`


    Alias of python builtin `map`  
    - **params:**  
    `func`: the function  
    - **returns:**  
    The transformed Channel  
          - method: `mapCol (self, func, col)`


    Map for a column  
    - **params:**  
    `func`: the function  
    `col`: the index of the column. Default: 0  
    - **returns:**  
    The transformed Channel  
          - staticmethod: `nones (length, width)`


    Create a channel with `None`s  
    - **params:**  
    `length`: The length of the channel  
    `width`:  The width of the channel  
    - **returns:**  
    The created channel  
          - method: `pop ()`

    L.pop([index]) -&gt; item -- remove and return item at index (default last).  
    Raises IndexError if list is empty or index is out of range.      - method: `rbind (self, *rows)`


    The multiple-argument versoin of `rbind`  
    - **params:**  
    `rows`: the rows to be bound to Channel  
    - **returns:**  
    The combined Channel  
    Note, self is also changed  
          - method: `reduce (self, func)`


    Alias of python builtin `reduce`  
    - **params:**  
    `func`: the function  
    - **returns:**  
    The reduced value  
          - method: `reduceCol (self, func, col)`


    Reduce a column  
    - **params:**  
    `func`: the function  
    `col`: the column to reduce  
    - **returns:**  
    The reduced value  
          - method: `remove ()`

    L.remove(value) -- remove first occurrence of value.  
    Raises ValueError if the value is not present.      - method: `repCol (self, n)`


    Repeat column and return a new channel  
    - **params:**  
    `n`: how many times to repeat.  
    - **returns:**  
    The new channel with repeated columns  
          - method: `repRow (self, n)`


    Repeat row and return a new channel  
    - **params:**  
    `n`: how many times to repeat.  
    - **returns:**  
    The new channel with repeated rows  
          - method: `reverse ()`

    L.reverse() -- reverse *IN PLACE*      - method: `rowAt (self, index)`


    Fetch one row of a Channel  
    - **params:**  
    `index`: which row to fetch  
    - **returns:**  
    The Channel with that row  
          - method: `slice (self, start, length)`


    Fetch some columns of a Channel  
    - **params:**  
    `start`:  from column to start  
    `length`: how many columns to fetch, default: None (from start to the end)  
    - **returns:**  
    The Channel with fetched columns  
          - method: `sort ()`

    L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;  
    cmp(x, y) -&gt; -1, 0, 1      - method: `split (self, flatten)`


    Split a Channel to single-column Channels  
    - **returns:**  
    The list of single-column Channels  
          - method: `t (self)`


    Transpose the channel  
    - **returns:**  
    The transposed channel.  
          - method: `transpose (self)`


    Transpose the channel  
    - **returns:**  
    The transposed channel.  
          - method: `unfold (self, n)`


    Do the reverse thing as self.fold does  
    - **params:**  
    `n`: How many rows to combind each time. default: 2  
    - **returns:**  
    The unfolded Channel  
          - method: `unique (self)`


    Make the channel unique, remove duplicated rows  
    Try to keep the order  
          - method: `width (self)`


    Get the width of a Channel  
    - **returns:**  
    The width of the Channel  
      # module: pyppl.exception
</code></pre>
<p>A set of exceptions used by PyPPL<br />
  !!! hint class: <code>PyPPLProcFindError</code></p>
<pre><code>Raise when failed to find a proc  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, p, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `PyPPLProcRelationError`


Raise when failed to parse the relation of processes  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, p, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `TemplatePyPPLSyntaxError`


Raised when a template has a syntax error.  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, src, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ProcAttributeError`


Raise when set/get process' attributes  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `TemplatePyPPLRenderError`


Failed to render a template  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, stack, src)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ProcInputError`


Raise when failed to parse process input  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `LoggerThemeError`


Theme errors for logger  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `JobInputParseError`


Raise when failed to parse the input data for jobs  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ParameterNameError`


Malformed name not allowed  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `JobOutputParseError`


Raise when failed to parse the output data for jobs  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ProcRunCmdError`


Raise when failed to run before/after cmds for process  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, cmd, key, ex)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ProcTreeParseError`


Raise when failed to parse the tree  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `AggrKeyError`


Raise when error occurred doing aggr[...]  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, key, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `AggrCopyError`


Raise when there is an error to set/get Aggr attributes  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, key, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `PyPPLConfigError`


Raise when failed to parse the configuration of pyppl  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, key, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ProcTagError`


Raise when malformed tag is assigned to a process  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ParametersLoadError`


Error loading dict to Parameters  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `AggrAttributeError`


Raise when there is an error to set/get Aggr attributes  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, key, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ParameterTypeError`


Unable to set type  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `RunnerSshError`


Raise when failed to initiate RunnerSsh  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ParametersParseError`


Error when parsing the parameters  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ProcOutputError`


Raise when failed to parse process output  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ProcTreeProcExists`


Raise when two Procs with same id and tag defined  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, pn1, pn2)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ProcScriptError`


Raise when failed to parse process script  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  # module: pyppl.flowchart
</code></pre>
<p>!!! hint function: <code>deepcopy (x, memo, _nil)</code></p>
<pre><code>Deep copy operation on arbitrary Python objects.

See the module's __doc__ string for more info.  
  !!! hint class: `Digraph`

Directed graph source code in the DOT language.

Args:  
name: Graph name used in the source code.  
comment: Comment added to the first line of the source.  
filename: Filename for saving the source (defaults to `name` + '.gv').  
directory: (Sub)directory for source saving and rendering.  
format: Rendering output format ('pdf', 'png', ...).  
engine: Layout command used ('dot', 'neato', ...).  
encoding: Encoding for saving the source.  
graph_attr: Mapping of (attribute, value) pairs for the graph.  
node_attr: Mapping of (attribute, value) pairs set for all nodes.  
edge_attr: Mapping of (attribute, value) pairs set for all edges.  
body: Iterable of verbatim lines to add to the graph body.  
strict(bool): Rendering should merge multi-edges.

.. note::  
All parameters are optional and can be changed under their  
corresponding attribute name after instance creation.  
      - method: `__init__ (self, name, comment, filename, directory, format, engine, encoding, graph_attr, node_attr, edge_attr, body, strict)`

          - method: `__iter__ (self, subgraph)`

    Yield the DOT source code line by line (as graph or subgraph).      - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ (self)`

    The DOT source code as string.      - staticmethod: `_a_list (label, kwargs, attributes)`

    Return assembled DOT a_list string.

    &gt;&gt;&gt; a_list('spam', {'spam': None, 'ham': 'ham ham', 'eggs': ''})  
    'label=spam eggs="" ham="ham ham"'  
          - staticmethod: `_attr_list (label, kwargs, attributes)`

    Return assembled DOT attribute list string.

    Sorts kwargs and attributes if they are plain dicts (to avoid  
    unpredictable order from hash randomization in Python 3.3+).

    &gt;&gt;&gt; attr_list()  
    ''

    &gt;&gt;&gt; attr_list('spam spam', kwargs={'eggs': 'eggs', 'ham': 'ham ham'})  
    ' [label="spam spam" eggs=eggs ham="ham ham"]'

    &gt;&gt;&gt; attr_list(kwargs={'spam': None, 'eggs': ''})  
    ' [eggs=""]'  
          - method: `_kwargs (self)`

          - staticmethod: `_quote (identifier, valid_id, dot_keyword, html)`

    Return DOT identifier from string, quote if needed.

    &gt;&gt;&gt; quote('')  
    '""'

    &gt;&gt;&gt; quote('spam')  
    'spam'

    &gt;&gt;&gt; quote('spam spam')  
    '"spam spam"'

    &gt;&gt;&gt; quote('-4.2')  
    '-4.2'

    &gt;&gt;&gt; quote('.42')  
    '.42'

    &gt;&gt;&gt; quote('&lt;&lt;b&gt;spam&lt;/b&gt;&gt;')  
    '&lt;&lt;b&gt;spam&lt;/b&gt;&gt;'  
          - staticmethod: `_quote_edge (identifier)`

    Return DOT edge statement node_id from string, quote if needed.

    &gt;&gt;&gt; quote_edge('spam')  
    'spam'

    &gt;&gt;&gt; quote_edge('spam spam:eggs eggs')  
    '"spam spam":"eggs eggs"'

    &gt;&gt;&gt; quote_edge('spam:eggs:s')  
    'spam:eggs:s'  
          - method: `_repr_svg_ (self)`

          - method: `_view (self, filepath, format)`

    Start the right viewer based on file format and platform.      - staticmethod: `_view_darwin (filepath)`

    Open filepath with its default application (mac).      - staticmethod: `_view_freebsd (filepath)`

    Open filepath in the user's preferred application (linux, freebsd).      - staticmethod: `_view_linux (filepath)`

    Open filepath in the user's preferred application (linux, freebsd).      - staticmethod: `_view_windows (filepath)`

    Start filepath with its associated application (windows).      - method: `attr (self, kw, _attributes, **attrs)`

    Add a general or graph/node/edge attribute statement.

    Args:  
    kw: Attributes target (None or 'graph', 'node', 'edge').  
    attrs: Attributes to be set (must be strings, may be empty).

    See the :ref:`usage examples in the User Guide &lt;attributes&gt;`.  
          - method: `clear (self, keep_attrs)`

    Reset content to an empty body, clear graph/node/egde_attr mappings.

    Args:  
    keep_attrs(bool): preserve graph/node/egde_attr mappings  
          - method: `copy (self)`

    Return a copied instance of the object.      - method: `edge (self, tail_name, head_name, label, _attributes, **attrs)`

    Create an edge between two nodes.

    Args:  
    tail_name: Start node identifier.  
    head_name: End node identifier.  
    label: Caption to be displayed near the edge.  
    attrs: Any additional edge attributes (must be strings).  
          - method: `edges (self, tail_head_iter)`

    Create a bunch of edges.

    Args:  
    tail_head_iter: Iterable of (tail_name, head_name) pairs.  
          - method: `node (self, name, label, _attributes, **attrs)`

    Create a node.

    Args:  
    name: Unique identifier for the node inside the source.  
    label: Caption to be displayed (defaults to the node name).  
    attrs: Any additional node attributes (must be strings).  
          - method: `pipe (self, format)`

    Return the source piped through the Graphviz layout command.

    Args:  
    format: The output format used for rendering ('pdf', 'png', etc.).  
    Returns:  
    Binary (encoded) stdout of the layout command.  
    Raises:  
    ValueError: If `format` is not known.  
    graphviz.ExecutableNotFound: If the Graphviz executable is not found.  
    subprocess.CalledProcessError: If the exit status is non-zero.  
          - method: `render (self, filename, directory, view, cleanup)`

    Save the source to file and render with the Graphviz engine.

    Args:  
    filename: Filename for saving the source (defaults to `name` + '.gv')  
    directory: (Sub)directory for source saving and rendering.  
    view(bool): Open the rendered result with the default application.  
    cleanup(bool): Delete the source file after rendering.  
    Returns:  
    The (possibly relative) path of the rendered file.  
    Raises:  
    graphviz.ExecutableNotFound: If the Graphviz executable is not found.  
    subprocess.CalledProcessError: If the exit status is non-zero.  
    RuntimeError: If viewer opening is requested but not supported.  
          - method: `save (self, filename, directory)`

    Save the DOT source to file. Ensure the file ends with a newline.

    Args:  
    filename: Filename for saving the source (defaults to `name` + '.gv')  
    directory: (Sub)directory for source saving and rendering.  
    Returns:  
    The (possibly relative) path of the saved source file.  
          - method: `subgraph (self, graph, name, comment, graph_attr, node_attr, edge_attr, body)`

    Add the current content of the given sole `graph` argument as subgraph            or return a context manager returning a new graph instance created            with the given (`name`, `comment`, etc.) arguments whose content is            added as subgraph when leaving the context manager's ``with``-block.

    Args:  
    graph: An instance of the same kind (:class:`.Graph`, :class:`.Digraph`)  
    as the current graph (sole argument in non-with-block use).  
    name: Subgraph name (with-block use).  
    comment: Subgraph comment (with-block use).  
    graph_attr: Subgraph-level attribute-value mapping (with-block use).  
    node_attr: Node-level attribute-value mapping (with-block use).  
    edge_attr: Edge-level attribute-value mapping (with-block use).  
    body: Verbatim lines to add to the subgraph body (with-block use).

    See the :ref:`usage examples in the User Guide &lt;subgraphs&gt;`.

    .. note::  
    If the `name` of the subgraph begins with 'cluster' (all lowercase)  
    the layout engine will treat it as a special cluster subgraph.  
          - method: `view (self, filename, directory, cleanup)`

    Save the source to file, open the rendered result in a viewer.

    Args:  
    filename: Filename for saving the source (defaults to name + '.gv')  
    directory: (Sub)directory for source saving and rendering.  
    cleanup(bool): Delete the source file after rendering.  
    Returns:  
    The (possibly relative) path of the rendered file.  
    Raises:  
    graphviz.ExecutableNotFound: If the Graphviz executable is not found.  
    subprocess.CalledProcessError: If the exit status is non-zero.  
    RuntimeError: If opening the viewer is not supported.

    Short-cut method for calling :meth:`.render` with ``view=True``.  
      !!! hint class: `Flowchart`


Draw flowchart for pipelines

- **static variables:**  
`THEMES`: predefined themes  
      - method: `__init__ (self, fcfile, dotfile)`


    The constructor  
    - **params:**  
    `fcfile`: The flowchart file. Default: `path.splitext(sys.argv[0])[0] + '.pyppl.svg'`  
    `dotfile`: The dot file. Default: `path.splitext(sys.argv[0])[0] + '.pyppl.dot'`  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_assemble (self)`


    Assemble the graph for printing and rendering  
          - method: `addLink (self, node1, node2)`


    Add a link to the chart  
    - **params:**  
    `node1`: The first node.  
    `node2`: The second node.  
          - method: `addNode (self, node, role)`


    Add a node to the chart  
    - **params:**  
    `node`: The node  
    `role`: Is it a starting node, an ending node or None. Default: None.  
          - method: `generate (self)`


    Generate the dot file and graph file.  
          - method: `setTheme (self, theme, base)`


    Set the theme to be used  
    - **params:**  
    `theme`: The theme, could be the key of Flowchart.THEMES or a dict of a theme definition.  
    `base` : The base theme to be based on you pass custom theme  
      # module: pyppl.job
</code></pre>
<p>Job module for pyppl<br />
  !!! hint class: <code>JobInputParseError</code></p>
<pre><code>Raise when failed to parse the input data for jobs  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint function: `Lock ()`


Returns a non-recursive lock object  
  !!! hint function: `glob (pathname)`

Return a list of paths matching a pathname pattern.

The pattern may contain simple shell-style wildcards a la  
fnmatch. However, unlike fnmatch, filenames starting with a  
dot are special cases that are not matched by '*' and '?'  
patterns.

  !!! hint class: `datetime`

datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])

The year, month and day arguments are required. tzinfo may be None, or an  
instance of a tzinfo subclass. The remaining arguments may be ints or longs.  
      - method: `__add__ ()`

    x.__add__(y) &lt;==&gt; x+y      - method: `__ge__ ()`

    x.__ge__(y) &lt;==&gt; x&gt;=y      - method: `__gt__ ()`

    x.__gt__(y) &lt;==&gt; x&gt;y      - method: `__init__ ()`

    x.__init__(...) initializes x; see help(type(x)) for signature      - method: `__le__ ()`

    x.__le__(y) &lt;==&gt; x&lt;=y      - method: `__lt__ ()`

    x.__lt__(y) &lt;==&gt; x&lt;y      - method: `__radd__ ()`

    x.__radd__(y) &lt;==&gt; y+x      - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__rsub__ ()`

    x.__rsub__(y) &lt;==&gt; y-x      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `__sub__ ()`

    x.__sub__(y) &lt;==&gt; x-y      - method: `astimezone ()`

    tz -&gt; convert to local time in new timezone tz  
          - method: `combine ()`

    date, time -&gt; datetime with same date and time fields      - method: `ctime ()`

    Return ctime() style string.      - method: `date ()`

    Return date object with same year, month and day.      - method: `dst ()`

    Return self.tzinfo.dst(self).      - method: `fromordinal ()`

    int -&gt; date corresponding to a proleptic Gregorian ordinal.      - method: `fromtimestamp ()`

    timestamp[, tz] -&gt; tz's local time from POSIX timestamp.      - method: `isocalendar ()`

    Return a 3-tuple containing ISO year, week number, and weekday.      - method: `isoformat ()`

    [sep] -&gt; string in ISO 8601 format, YYYY-MM-DDTHH:MM:SS[.mmmmmm][+HH:MM].

    sep is used to separate the year from the time, and defaults to 'T'.      - method: `isoweekday ()`

    Return the day of the week represented by the date.  
    Monday == 1 ... Sunday == 7      - method: `now ()`

    [tz] -&gt; new datetime with tz's local day and time.      - method: `replace ()`

    Return datetime with new specified fields.      - method: `strftime ()`

    format -&gt; strftime() style string.      - method: `strptime ()`

    string, format -&gt; new datetime parsed from a string (like time.strptime()).      - method: `time ()`

    Return time object with same time but with tzinfo=None.      - method: `timetuple ()`

    Return time tuple, compatible with time.localtime().      - method: `timetz ()`

    Return time object with same time and tzinfo.      - method: `today ()`

    Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).      - method: `toordinal ()`

    Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.      - method: `tzname ()`

    Return self.tzinfo.tzname(self).      - method: `utcfromtimestamp ()`

    timestamp -&gt; UTC datetime from a POSIX timestamp (like time.time()).      - method: `utcnow ()`

    Return a new datetime representing UTC day and time.      - method: `utcoffset ()`

    Return self.tzinfo.utcoffset(self).      - method: `utctimetuple ()`

    Return UTC time tuple, compatible with time.localtime().      - method: `weekday ()`

    Return the day of the week represented by the date.  
    Monday == 0 ... Sunday == 6  !!! hint class: `JobOutputParseError`


Raise when failed to parse the output data for jobs  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `Job`


Job class, defining a job in a process  
      - method: `__init__ (self, index, proc)`


    Constructor  
    - **params:**  
    `index`:   The index of the job in a process  
    `proc`:    The process  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_indexIndicator (self)`


    Get the index indicator in the log  
    - **returns:**  
    The "[001/100]" like indicator  
          - method: `_linkInfile (self, orgfile)`


    Create links for input files  
    - **params:**  
    `orgfile`: The original input file  
    - **returns:**  
    The link to the original file.  
          - method: `_prepInput (self)`


    Prepare input, create link to input files and set other placeholders  
          - method: `_prepOutput (self)`


    Build the output data.  
    Output could be:  
    1. list: `['output:var:{{input}}', 'outfile:file:{{infile.bn}}.txt']`  
    or you can ignore the name if you don't put it in script:  
    `['var:{{input}}', 'path:{{infile.bn}}.txt']`  
    or even (only var type can be ignored):  
    `['{{input}}', 'file:{{infile.bn}}.txt']`  
    2. str : `'output:var:{{input}}, outfile:file:{{infile.bn}}.txt'`  
    3. OrderedDict: `{"output:var:{{input}}": channel1, "outfile:file:{{infile.bn}}.txt": channel2}`  
    or    `{"output:var:{{input}}, output:file:{{infile.bn}}.txt" : channel3}`  
    for 1,2 channels will be the property channel for this proc (i.e. p.channel)  
          - method: `_prepScript (self)`


    Build the script, interpret the placeholders  
          - method: `_reportItem (self, key, maxlen, data, loglevel)`


    Report the item on logs  
    - **params:**  
    `key`: The key of the item  
    `maxlen`: The max length of the key  
    `data`: The data of the item  
    `loglevel`: The log level  
          - method: `cache (self)`


    Truly cache the job (by signature)  
          - method: `checkOutfiles (self, expect)`


    Check whether output files are generated, if not, add - to rc.  
          - method: `done (self)`


    Do some cleanup when job finished  
          - method: `export (self)`


    Export the output files  
          - method: `init (self)`


    Initiate a job, make directory and prepare input, output and script.  
          - method: `isExptCached (self)`


    Prepare to use export files as cached information  
    True if succeed, otherwise False  
          - method: `isTrulyCached (self)`


    Check whether a job is truly cached (by signature)  
          - method: `pid (self, val)`


    Get/Set the job id (pid or the id from queue system)  
    - **params:**  
    `val`: The id to be set  
          - method: `rc (self, val)`


    Get/Set the return code  
    - **params:**  
    `val`: The return code to be set. If it is None, return the return code. Default: `None`  
    If val == -1000: the return code will be negative of current one. 0 will be '-0'  
    - **returns:**  
    The return code if `val` is `None`  
    If rcfile does not exist or is empty, return 9999, otherwise return -rc  
    A negative rc (including -0) means output files not generated  
          - method: `report (self)`


    Report the job information to logger  
          - method: `reset (self, retry)`


    Clear the intermediate files and output files  
          - method: `showError (self, totalfailed)`


    Show the error message if the job failed.  
          - method: `signature (self)`


    Calculate the signature of the job based on the input/output and the script  
    - **returns:**  
    The signature of the job  
          - method: `succeed (self)`


    Tell if the job is successful by return code, and output file expectations.  
    - **returns:**  
    True if succeed else False  
      # module: pyppl.jobmgr
</code></pre>
<p>!!! hint function: <code>JoinableQueue (maxsize)</code></p>
<pre><code>Returns a queue object  
  !!! hint class: `Jobmgr`


Job Manager  
      - method: `__init__ (self, proc, runner)`


    Job manager constructor  
    - **params:**  
    `proc`     : The process  
    `runner`   : The runner class  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_exit (self)`

          - method: `allJobsDone (self)`


    Tell whether all jobs are done.  
    No need to lock as it only runs in one process (the watcher process)  
    - **returns:**  
    `True` if all jobs are done else `False`  
          - method: `canSubmit (self)`


    Tell whether we can submit jobs.  
    - **returns:**  
    `True` if we can, otherwise `False`  
          - method: `halt (self, halt_anyway)`


    Halt the pipeline if needed  
          - method: `progressbar (self, jid, loglevel)`

          - method: `run (self)`


    Start to run the jobs  
          - method: `runPool (self, rq, sq)`


    The pool to run jobs (wait jobs to be done)  
    - **params:**  
    `rq`: The run queue  
    `sq`: The submit queue  
          - method: `submitPool (self, sq)`


    The pool to submit jobs  
    - **params:**  
    `sq`: The submit queue  
          - method: `watchPool (self, rq, sq)`


    The watchdog, checking whether all jobs are done.  
      !!! hint class: `Process`


Process objects represent activity that is run in a separate process

The class is analagous to `threading.Thread`  
      - method: `__init__ (self, group, target, name, args, kwargs)`

          - method: `__repr__ (self)`

          - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_bootstrap (self)`

          - method: `is_alive (self)`


    Return whether process is alive  
          - method: `join (self, timeout)`


    Wait until child process terminates  
          - method: `run (self)`


    Method to be run in sub-process; can be overridden in sub-class  
          - method: `start (self)`


    Start child process  
          - method: `terminate (self)`


    Terminate process; sends SIGTERM signal or uses TerminateProcess()  
      !!! hint function: `Lock ()`


Returns a non-recursive lock object  
  !!! hint function: `Array (typecode_or_type, size_or_initializer, **kwds)`


Returns a synchronized shared array  
  # module: pyppl.logger
</code></pre>
<p>A customized logger for pyppl<br />
  !!! hint class: <code>Box</code></p>
<pre><code>Allow dot operation for OrderedDict  
      - method: `_OrderedDict__update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `__cmp__ ()`

    x.__cmp__(y) &lt;==&gt; cmp(x,y)      - method: `__contains__ ()`

    D.__contains__(k) -&gt; True if D has a key k, else False      - method: `__delitem__ (self, key, dict_delitem)`

    od.__delitem__(y) &lt;==&gt; del od[y]      - method: `__ge__ ()`

    x.__ge__(y) &lt;==&gt; x&gt;=y      - method: `__getattr__ (self, name)`

          - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__gt__ ()`

    x.__gt__(y) &lt;==&gt; x&gt;y      - method: `__init__ (*args, **kwds)`

    Initialize an ordered dictionary.  The signature is the same as  
    regular dictionaries, but keyword arguments are not recommended because  
    their insertion order is arbitrary.

          - method: `__iter__ (self)`

    od.__iter__() &lt;==&gt; iter(od)      - method: `__le__ ()`

    x.__le__(y) &lt;==&gt; x&lt;=y      - method: `__len__ ()`

    x.__len__() &lt;==&gt; len(x)      - method: `__lt__ ()`

    x.__lt__(y) &lt;==&gt; x&lt;y      - method: `__repr__ (self, _repr_running)`

    od.__repr__() &lt;==&gt; repr(od)      - method: `__reversed__ (self)`

    od.__reversed__() &lt;==&gt; reversed(od)      - method: `__setattr__ (self, name, val)`

          - method: `__setitem__ (self, key, value, dict_setitem)`

    od.__setitem__(i, y) &lt;==&gt; od[i]=y      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `clear (self)`

    od.clear() -&gt; None.  Remove all items from od.      - method: `copy (self)`

    od.copy() -&gt; a shallow copy of od      - method: `fromkeys (cls, iterable, value)`

    OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.  
    If not specified, the value defaults to None.

          - method: `get ()`

    D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.      - method: `has_key ()`

    D.has_key(k) -&gt; True if D has a key k, else False      - method: `items (self)`

    od.items() -&gt; list of (key, value) pairs in od      - method: `iteritems (self)`

    od.iteritems -&gt; an iterator over the (key, value) pairs in od      - method: `iterkeys (self)`

    od.iterkeys() -&gt; an iterator over the keys in od      - method: `itervalues (self)`

    od.itervalues -&gt; an iterator over the values in od      - method: `keys (self)`

    od.keys() -&gt; list of keys in od      - method: `pop (self, key, default)`

    od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding  
    value.  If key is not found, d is returned if given, otherwise KeyError  
    is raised.

          - method: `popitem (self, last)`

    od.popitem() -&gt; (k, v), return and remove a (key, value) pair.  
    Pairs are returned in LIFO order if last is true or FIFO order if false.

          - method: `setdefault (self, key, default)`

    od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od      - method: `update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `values (self)`

    od.values() -&gt; list of values in od      - method: `viewitems (self)`

    od.viewitems() -&gt; a set-like object providing a view on od's items      - method: `viewkeys (self)`

    od.viewkeys() -&gt; a set-like object providing a view on od's keys      - method: `viewvalues (self)`

    od.viewvalues() -&gt; an object providing a view on od's values  !!! hint class: `PyPPLStreamHandler`


PyPPL stream log handler.  
To implement the progress bar for JOBONE and SUBMIT logs.  
      - method: `__init__ (self, stream)`


    Constructor  
    - **params:**  
    `stream`: The stream  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_emit (self, record, terminator)`


    Helper function implementing a python2,3-compatible emit.  
    Allow to add "  
    " or "
</code></pre>
<p>" as terminator.<br />
              - method: <code>acquire (self)</code></p>
<pre><code>    Acquire the I/O thread lock.  
          - method: `addFilter (self, filter)`


    Add the specified filter to this handler.  
          - method: `close (self)`


    Tidy up any resources used by the handler.

    This version removes the handler from an internal map of handlers,  
    _handlers, which is used for handler lookup by name. Subclasses  
    should ensure that this gets called from overridden close()  
    methods.  
          - method: `createLock (self)`


    Acquire a thread lock for serializing access to the underlying I/O.  
          - method: `emit (self, record)`


    Emit the record.  
          - method: `filter (self, record)`


    Determine if a record is loggable by consulting all the filters.

    The default is to allow the record to be logged; any filter can veto  
    this and the record is then dropped. Returns a zero value if a record  
    is to be dropped, else non-zero.  
          - method: `flush (self)`


    Flushes the stream.  
          - method: `format (self, record)`


    Format the specified record.

    If a formatter is set, use it. Otherwise, use the default formatter  
    for the module.  
          - method: `get_name (self)`

          - method: `handle (self, record)`


    Conditionally emit the specified logging record.

    Emission depends on filters which may have been added to the handler.  
    Wrap the actual emission of the record with acquisition/release of  
    the I/O thread lock. Returns whether the filter passed the record for  
    emission.  
          - method: `handleError (self, record)`


    Handle errors which occur during an emit() call.

    This method should be called from handlers when an exception is  
    encountered during an emit() call. If raiseExceptions is false,  
    exceptions get silently ignored. This is what is mostly wanted  
    for a logging system - most users will not care about errors in  
    the logging system, they are more interested in application errors.  
    You could, however, replace this with a custom handler if you wish.  
    The record which was being processed is passed in to this method.  
          - method: `release (self)`


    Release the I/O thread lock.  
          - method: `removeFilter (self, filter)`


    Remove the specified filter from this handler.  
          - method: `setFormatter (self, fmt)`


    Set the formatter for this handler.  
          - method: `setLevel (self, level)`


    Set the logging level of this handler.  
          - method: `set_name (self, name)`

      !!! hint class: `LoggerThemeError`


Theme errors for logger  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `PyPPLLogFormatter`


logging formatter for pyppl  
      - method: `__init__ (self, fmt, theme, secondary)`


    Constructor  
    - **params:**  
    `fmt`      : The format  
    `theme`    : The theme  
    `secondary`: Whether this is a secondary formatter or not (another formatter applied before this).  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `converter ()`

    localtime([seconds]) -&gt; (tm_year,tm_mon,tm_mday,tm_hour,tm_min,  
    tm_sec,tm_wday,tm_yday,tm_isdst)

    Convert seconds since the Epoch to a time tuple expressing local time.  
    When 'seconds' is not passed in, convert the current time instead.      - method: `format (self, record)`


    Format the record  
    - **params:**  
    `record`: The log record  
    - **returns:**  
    The formatted record  
          - method: `formatException (self, ei)`


    Format and return the specified exception information as a string.

    This default implementation just uses  
    traceback.print_exception()  
          - method: `formatTime (self, record, datefmt)`


    Return the creation time of the specified LogRecord as formatted text.

    This method should be called from format() by a formatter which  
    wants to make use of a formatted time. This method can be overridden  
    in formatters to provide for any specific requirement, but the  
    basic behaviour is as follows: if datefmt (a string) is specified,  
    it is used with time.strftime() to format the creation time of the  
    record. Otherwise, the ISO8601 format is used. The resulting  
    string is returned. This function uses a user-configurable function  
    to convert the creation time to a tuple. By default, time.localtime()  
    is used; to change this for a particular formatter instance, set the  
    'converter' attribute to a function with the same signature as  
    time.localtime() or time.gmtime(). To change it for all formatters,  
    for example if you want all logging times to be shown in GMT,  
    set the 'converter' attribute in the Formatter class.  
          - method: `usesTime (self)`


    Check if the format uses the creation time of the record.  
      !!! hint class: `PyPPLLogFilter`


logging filter by levels (flags)  
      - method: `__init__ (self, name, lvls, lvldiff)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `filter (self, record)`

      !!! hint function: `_getLevel (record)`


Get the flags of a record  
- **params:**  
`record`:  The logging record  
  !!! hint function: `Value (typecode_or_type, *args, **kwds)`


Returns a synchronized shared object  
  !!! hint function: `_formatTheme (theme)`


Make them in the standard form with bgcolor and fgcolor in raw terminal color strings  
If the theme is read from file, try to translate "COLORS.xxx" to terminal color strings  
- **params:**  
`theme`: The theme  
- **returns:**  
The formatted colors  
  !!! hint function: `_getColorFromTheme (level, theme)`


Get colors from a them  
- **params:**  
`level`: Our own log record level  
`theme`: The theme  
- **returns:**  
The colors  
  !!! hint class: `TemplatePyPPL`


Built-in template wrapper.  
      - method: `__init__ (self, source, **envs)`


    Initiate the engine with source and envs  
    - **params:**  
    `source`: The souce text  
    `envs`: The env data  
          - method: `__repr__ (self)`

          - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ (self)`

          - method: `_render (self, data)`


    Render the template  
    - **params:**  
    `data`: The data used for rendering  
    - **returns:**  
    The rendered string  
          - method: `registerEnvs (self, **envs)`

          - method: `render (self, data)`

      !!! hint function: `getLogger (levels, theme, logfile, lvldiff, pbar, name)`


Get the default logger  
- **params:**  
`levels`: The log levels(tags), default: basic  
`theme`:  The theme of the logs on terminal. Default: True (default theme will be used)  
- False to disable theme  
`logfile`:The log file. Default: None (don't white to log file)  
`lvldiff`:The diff levels for log  
- ["-depends", "jobdone", "+debug"]: show jobdone, hide depends and debug  
`name`:   The name of the logger, default: PyPPL  
- **returns:**  
The logger  
  # module: pyppl.parameters
</code></pre>
<p>!!! hint class: <code>Box</code></p>
<pre><code>Allow dot operation for OrderedDict  
      - method: `_OrderedDict__update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `__cmp__ ()`

    x.__cmp__(y) &lt;==&gt; cmp(x,y)      - method: `__contains__ ()`

    D.__contains__(k) -&gt; True if D has a key k, else False      - method: `__delitem__ (self, key, dict_delitem)`

    od.__delitem__(y) &lt;==&gt; del od[y]      - method: `__ge__ ()`

    x.__ge__(y) &lt;==&gt; x&gt;=y      - method: `__getattr__ (self, name)`

          - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__gt__ ()`

    x.__gt__(y) &lt;==&gt; x&gt;y      - method: `__init__ (*args, **kwds)`

    Initialize an ordered dictionary.  The signature is the same as  
    regular dictionaries, but keyword arguments are not recommended because  
    their insertion order is arbitrary.

          - method: `__iter__ (self)`

    od.__iter__() &lt;==&gt; iter(od)      - method: `__le__ ()`

    x.__le__(y) &lt;==&gt; x&lt;=y      - method: `__len__ ()`

    x.__len__() &lt;==&gt; len(x)      - method: `__lt__ ()`

    x.__lt__(y) &lt;==&gt; x&lt;y      - method: `__repr__ (self, _repr_running)`

    od.__repr__() &lt;==&gt; repr(od)      - method: `__reversed__ (self)`

    od.__reversed__() &lt;==&gt; reversed(od)      - method: `__setattr__ (self, name, val)`

          - method: `__setitem__ (self, key, value, dict_setitem)`

    od.__setitem__(i, y) &lt;==&gt; od[i]=y      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `clear (self)`

    od.clear() -&gt; None.  Remove all items from od.      - method: `copy (self)`

    od.copy() -&gt; a shallow copy of od      - method: `fromkeys (cls, iterable, value)`

    OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.  
    If not specified, the value defaults to None.

          - method: `get ()`

    D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.      - method: `has_key ()`

    D.has_key(k) -&gt; True if D has a key k, else False      - method: `items (self)`

    od.items() -&gt; list of (key, value) pairs in od      - method: `iteritems (self)`

    od.iteritems -&gt; an iterator over the (key, value) pairs in od      - method: `iterkeys (self)`

    od.iterkeys() -&gt; an iterator over the keys in od      - method: `itervalues (self)`

    od.itervalues -&gt; an iterator over the values in od      - method: `keys (self)`

    od.keys() -&gt; list of keys in od      - method: `pop (self, key, default)`

    od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding  
    value.  If key is not found, d is returned if given, otherwise KeyError  
    is raised.

          - method: `popitem (self, last)`

    od.popitem() -&gt; (k, v), return and remove a (key, value) pair.  
    Pairs are returned in LIFO order if last is true or FIFO order if false.

          - method: `setdefault (self, key, default)`

    od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od      - method: `update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `values (self)`

    od.values() -&gt; list of values in od      - method: `viewitems (self)`

    od.viewitems() -&gt; a set-like object providing a view on od's items      - method: `viewkeys (self)`

    od.viewkeys() -&gt; a set-like object providing a view on od's keys      - method: `viewvalues (self)`

    od.viewvalues() -&gt; an object providing a view on od's values  !!! hint class: `Commands`


Support sub-command for command line argument parse.  
      - method: `__getattr__ (self, name)`

          - method: `__getitem__ (self, name)`

          - method: `__init__ (self, theme)`


    Constructor  
    - **params:**  
    `theme`: The theme  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ (self, name, value)`

          - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_setDesc (self, desc)`


    Set the description  
    - **params:**  
    `desc`: The description  
          - method: `_setHcmd (self, hcmd)`


    Set the help command  
    - **params:**  
    `hcmd`: The help command  
          - method: `_setTheme (self, theme)`


    Set the theme  
    - **params:**  
    `theme`: The theme  
          - method: `help (self, error, printNexit)`


    Construct the help page  
    - **params:**  
    `error`: the error message  
    `printNexit`: print the help page and exit instead of return the help information  
    - **returns:**  
    The help information if `printNexit` is `False`  
          - method: `parse (self, args, arbi)`


    Parse the arguments.  
    - **params:**  
    `args`: The arguments (list). `sys.argv[1:]` will be used if it is `None`.  
    `arbi`: Whether do an arbitrary parse. If True, options don't need to be defined. Default: `False`  
    - **returns:**  
    A `tuple` with first element the subcommand and second the parameters being parsed.  
      !!! hint class: `Parameters`


A set of parameters  
      - method: `__call__ (self, option, value)`


    Set options values in `self._props`.  
    Will be deprecated in the future!  
    - **params:**  
    `option`: The key of the option  
    `value` : The value of the option  
    `excl`  : The value is used to exclude (only for `hopts`)  
    - **returns:**  
    `self`  
          - method: `__getattr__ (self, name)`

          - method: `__getitem__ (self, name)`

          - method: `__init__ (self, command, theme)`


    Constructor  
    - **params:**  
    `command`: The sub-command  
    `theme`: The theme  
          - method: `__repr__ (self)`

          - method: `__setattr__ (self, name, value)`

          - method: `__setitem__ (self, name, value)`

          - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - staticmethod: `_coerceValue (value, t)`


    Coerce a value to another type.  
    - **params:**  
    `value`: The value  
    `t`: The type  
          - method: `_parseName (self, argname)`


    If `argname` is the name of an option  
    - **params:**  
    `argname`: The argname  
    - **returns:**  
    `an`: clean argument name  
    `at`: normalized argument type  
    `av`: the argument value, if `argname` is like: `-a=1`  
          - method: `_putValue (self, argname, argtype, argval, arbi)`


    Save the values.  
    - **params:**  
    `argname`: The option name  
    `argtype`: The parsed type  
    `argval`:  The option value  
    `arbi`:    Whether allow pass options arbitrarily (without definition)  
    - **return:**  
    `True` if value append to a list option successfully, otherwise `False`  
          - method: `_setDesc (self, desc)`


    Set the description  
    - **params:**  
    `desc`: The description  
          - method: `_setHbald (self, hbald)`


    Set if we should show help information if no arguments passed.  
    - **params:**  
    `hbald`: The flag. show if True else hide. Default: `True`  
          - method: `_setHopts (self, hopts)`


    Set the help options  
    - **params:**  
    `hopts`: The help options  
          - method: `_setPrefix (self, prefix)`


    Set the option prefix  
    - **params:**  
    `prefix`: The prefix  
          - method: `_setTheme (self, theme)`


    Set the theme  
    - **params:**  
    `theme`: The theme  
          - method: `_setUsage (self, usage)`


    Set the usage  
    - **params:**  
    `usage`: The usage  
          - method: `_shouldPrintHelp (self, args)`

          - method: `asDict (self)`


    Convert the parameters to Box object  
    - **returns:**  
    The Box object  
          - method: `help (self, error, printNexit)`


    Calculate the help page  
    - **params:**  
    `error`: The error message to show before the help information. Default: `''`  
    `printNexit`: Print the help page and exit the program? Default: `False` (return the help information)  
    - **return:**  
    The help information  
          - method: `loadDict (self, dictVar, show)`


    Load parameters from a dict  
    - **params:**  
    `dictVar`: The dict variable.  
    - Properties are set by "&lt;param&gt;.required", "&lt;param&gt;.show", ...  
    `show`:    Whether these parameters should be shown in help information  
    - Default: False (don't show parameter from config object in help page)  
    - It'll be overwritten by the `show` property inside dict variable.  
    - If it is None, will inherit the param's show value  
          - method: `loadFile (self, cfgfile, show)`


    Load parameters from a json/config file  
    If the file name ends with '.json', `json.load` will be used,  
    otherwise, `ConfigParser` will be used.  
    For config file other than json, a section name is needed, whatever it is.  
    - **params:**  
    `cfgfile`: The config file  
    `show`:    Whether these parameters should be shown in help information  
    - Default: False (don't show parameter from config file in help page)  
    - It'll be overwritten by the `show` property inside the config file.  
          - method: `parse (self, args, arbi)`


    Parse the arguments.  
    - **params:**  
    `args`: The arguments (list). `sys.argv[1:]` will be used if it is `None`.  
    `arbi`: Whether do an arbitrary parse. If True, options don't need to be defined. Default: `False`  
    - **returns:**  
    A `Box`/`dict` object containing all option names and values.  
      !!! hint class: `ParametersLoadError`


Error loading dict to Parameters  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ParameterNameError`


Malformed name not allowed  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ParameterTypeError`


Unable to set type  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `HelpAssembler`


A helper class to help assembling the help information page.  
- **staticvars**  
`MAXPAGEWIDTH`: the max width of the help page, not including the leading space  
`MAXOPTWIDTH` : the max width of the option name (include the type and placeholder, but not the leading space)  
`THEMES`      : the themes  
      - method: `__init__ (self, prog, theme)`


    Constructor  
    - **params:**  
    `prog`: The program name  
    `theme`: The theme. Could be a name of `THEMES`, or a dict of a custom theme.  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - staticmethod: `_calcwidth (helps, progname)`

          - staticmethod: `_reallen (msg, progname)`

          - method: `assemble (self, helps, progname)`


    Assemble the whole help page.  
    - **params:**  
    `helps`: The help items. A list with plain strings or tuples of 3 elements, which  
    will be treated as option name, option type/placeholder and option descriptions.  
    `progname`: The program name used to replace '{prog}' with.  
    - **returns:**  
    lines (`list`) of the help information.  
          - method: `error (self, msg)`


    Render an error message  
    - **params:**  
    `msg`: The error message  
          - method: `optdesc (self, msg)`


    Render the option descriptions  
    - **params:**  
    `msg`: the option descriptions  
          - method: `optname (self, msg)`


    Render the option name  
    - **params:**  
    `msg`: The option name  
          - method: `opttype (self, msg)`


    Render the option type or placeholder  
    - **params:**  
    `msg`: the option type or placeholder  
          - method: `plain (self, msg)`


    Render a plain message  
    - **params:**  
    `msg`: the message  
          - method: `prog (self, prog)`


    Render the program name  
    - **params:**  
    `msg`: The program name  
          - method: `title (self, msg)`


    Render an section title  
    - **params:**  
    `msg`: The section title  
          - method: `warning (self, msg)`


    Render an warning message  
    - **params:**  
    `msg`: The warning message  
      !!! hint class: `Parameter`


The class for a single parameter  
      - method: `__getattr__ (self, name)`

          - method: `__init__ (self, name, value)`


    Constructor  
    - **params:**  
    `name`:  The name of the parameter  
    `value`: The initial value of the parameter  
          - method: `__repr__ (self)`

          - method: `__setattr__ (self, name, value)`

          - method: `__str__ (self)`

          - method: `_forceType (self)`


    Coerce the value to the type specified  
    TypeError will be raised if error happens  
          - method: `setDesc (self, d)`


    Set the description of the parameter  
    - **params:**  
    `d`: The description  
          - method: `setName (self, n)`


    Set the name of the parameter  
    - **params:**  
    `n`: The name  
          - method: `setRequired (self, r)`


    Set whether this parameter is required  
    - **params:**  
    `r`: True if required else False. Default: True  
          - method: `setShow (self, s)`


    Set whether this parameter should be shown in help information  
    - **params:**  
    `s`: True if it shows else False. Default: True  
          - method: `setType (self, t)`


    Set the type of the parameter  
    - **params:**  
    `t`: The type of the value. Default: str  
    - Note: str rather then 'str'  
          - method: `setValue (self, v)`


    Set the value of the parameter  
    - **params:**  
    `v`: The value  
      !!! hint class: `ParametersParseError`


Error when parsing the parameters  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  # module: pyppl.proctree
</code></pre>
<p>Manage process relations<br />
  !!! hint class: <code>ProcTreeProcExists</code></p>
<pre><code>Raise when two Procs with same id and tag defined  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, pn1, pn2)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `ProcNode`


The node for processes to manage relations between each other  
      - method: `__init__ (self, proc)`


    Constructor  
    - **params:**  
    `proc`: The `Proc` instance  
          - method: `__repr__ (self)`

          - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `sameIdTag (self, proc)`


    Check if the process has the same id and tag with me.  
    - **params:**  
    `proc`: The `Proc` instance  
    - **returns:**  
    `True` if it is.  
    `False` if not.  
      !!! hint class: `ProcTreeParseError`


Raise when failed to parse the tree  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  # module: pyppl.runners.helpers
</code></pre>
<p>!!! hint class: <code>Box</code></p>
<pre><code>Allow dot operation for OrderedDict  
      - method: `_OrderedDict__update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `__cmp__ ()`

    x.__cmp__(y) &lt;==&gt; cmp(x,y)      - method: `__contains__ ()`

    D.__contains__(k) -&gt; True if D has a key k, else False      - method: `__delitem__ (self, key, dict_delitem)`

    od.__delitem__(y) &lt;==&gt; del od[y]      - method: `__ge__ ()`

    x.__ge__(y) &lt;==&gt; x&gt;=y      - method: `__getattr__ (self, name)`

          - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__gt__ ()`

    x.__gt__(y) &lt;==&gt; x&gt;y      - method: `__init__ (*args, **kwds)`

    Initialize an ordered dictionary.  The signature is the same as  
    regular dictionaries, but keyword arguments are not recommended because  
    their insertion order is arbitrary.

          - method: `__iter__ (self)`

    od.__iter__() &lt;==&gt; iter(od)      - method: `__le__ ()`

    x.__le__(y) &lt;==&gt; x&lt;=y      - method: `__len__ ()`

    x.__len__() &lt;==&gt; len(x)      - method: `__lt__ ()`

    x.__lt__(y) &lt;==&gt; x&lt;y      - method: `__repr__ (self, _repr_running)`

    od.__repr__() &lt;==&gt; repr(od)      - method: `__reversed__ (self)`

    od.__reversed__() &lt;==&gt; reversed(od)      - method: `__setattr__ (self, name, val)`

          - method: `__setitem__ (self, key, value, dict_setitem)`

    od.__setitem__(i, y) &lt;==&gt; od[i]=y      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `clear (self)`

    od.clear() -&gt; None.  Remove all items from od.      - method: `copy (self)`

    od.copy() -&gt; a shallow copy of od      - method: `fromkeys (cls, iterable, value)`

    OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.  
    If not specified, the value defaults to None.

          - method: `get ()`

    D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.      - method: `has_key ()`

    D.has_key(k) -&gt; True if D has a key k, else False      - method: `items (self)`

    od.items() -&gt; list of (key, value) pairs in od      - method: `iteritems (self)`

    od.iteritems -&gt; an iterator over the (key, value) pairs in od      - method: `iterkeys (self)`

    od.iterkeys() -&gt; an iterator over the keys in od      - method: `itervalues (self)`

    od.itervalues -&gt; an iterator over the values in od      - method: `keys (self)`

    od.keys() -&gt; list of keys in od      - method: `pop (self, key, default)`

    od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding  
    value.  If key is not found, d is returned if given, otherwise KeyError  
    is raised.

          - method: `popitem (self, last)`

    od.popitem() -&gt; (k, v), return and remove a (key, value) pair.  
    Pairs are returned in LIFO order if last is true or FIFO order if false.

          - method: `setdefault (self, key, default)`

    od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od      - method: `update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `values (self)`

    od.values() -&gt; list of values in od      - method: `viewitems (self)`

    od.viewitems() -&gt; a set-like object providing a view on od's items      - method: `viewkeys (self)`

    od.viewkeys() -&gt; a set-like object providing a view on od's keys      - method: `viewvalues (self)`

    od.viewvalues() -&gt; an object providing a view on od's values  !!! hint class: `Helper`


A helper class for runners  
      - method: `__init__ (self, script, cmds)`


    Constructor  
    - **params:**  
    `script`: The script of the job  
    `cmds`  : The original runner commands  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `alive (self)`


    Tell if the job is alive  
          - method: `kill (self)`


    Kill the job  
          - method: `run (self)`


    Run the job, wait for the job to complete  
          - method: `submit (self)`


    Submit the job  
      !!! hint class: `SafeFs`


A thread-safe file system

- **static variables:**

`TMPDIR`: The default temporary directory to store lock files

# file types  
`FILETYPE_UNKNOWN`  : Unknown file type  
`FILETYPE_NOENT`    : File does not exist  
`FILETYPE_NOENTLINK`: A dead link (a link links to a non-existent file.  
`FILETYPE_FILE`     : A regular file  
`FILETYPE_FILELINK` : A link to a regular file  
`FILETYPE_DIR`      : A regular directory  
`FILETYPE_DIRLINK`  : A link to a regular directory

# relation of two files  
`FILES_DIFF_BOTHNOENT` : Two files are different and none of them exists  
`FILES_DIFF_NOENT1`    : Two files are different but file1 does not exists  
`FILES_DIFF_NOENT2`    : Two files are different but file2 does not exists  
`FILES_DIFF_BOTHENT`   : Two files are different and both of them exist  
`FILES_SAME_STRNOENT`  : Two files are the same string and it does not exist  
`FILES_SAME_STRENT`    : Two files are the same string and it exists  
`FILES_SAME_BOTHLINKS` : Two files link to one file  
`FILES_SAME_BOTHLINKS1`: File1 links to file2, file2 links to a regular file  
`FILES_SAME_BOTHLINKS2`: File2 links to file1, file1 links to a regular file  
`FILES_SAME_REAL1`     : File2 links to file1, which a regular file  
`FILES_SAME_REAL2`     : File1 links to file2, which a regular file

`LOCK`: A global lock ensures the locks are locked at the same time  
      - method: `__init__ (self, file1, file2, tmpdir)`


    Constructor  
    - **params:**  
    `file1`:  File 1  
    `file2`:  File 2. Default: `None`  
    `tmpdir`: The temporary directory used to store lock files. Default: `None` (`SafeFs.TMPDIR`)  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - staticmethod: `_copy (file1, file2, overwrite, filetype1, filetype2)`


    Copy a file or a directory  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - staticmethod: `_dirmtime (filepath)`


    Get the modified time of a directory recursively  
    - **params:**  
    `filepath`: The file path  
    - **return`:**  
    The most recent modified time  
          - staticmethod: `_exists (filepath, filetype)`


    Tell if a file exists  
    - **params:**  
    `filepath`: The source  
    `filetype`: The file type of file2  
    - **returns:**  
    `True` if exists else `False`  
          - staticmethod: `_filerel (file1, file2, filetype1, filetype2)`


    Check the relations between file1 and file2.  
    - **params:**  
    `file1`: The first file  
    `file2`: The second file  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `SafeFs.FILES_DIFF_BOTHNOENT`: they are different for whatever reason.  
    `SafeFs.FILES_DIFF_NOENT1`   : they are different for whatever reason.  
    `SafeFs.FILES_DIFF_NOENT2`   : they are different for whatever reason.  
    `SafeFs.FILES_DIFF_BOTHENT`  : they are different for whatever reason.  
    `SafeFs.FILES_SAME_STRENT`   : they are the same string and the file exists.  
    `SafeFs.FILES_SAME_STRNOENT` : they are the same string but the file doesn't exist.  
    `SafeFs.FILES_SAME_BOTHLINKS`: both of them are links to the same file.  
    `SafeFs.FILES_SAME_REAL1`    : file1 is the real file, file2 is a link to it.  
    `SafeFs.FILES_SAME_REAL2`    : file2 is the real file, file1 is a link to it.  
          - staticmethod: `_filetype (filepath)`


    Get the file type  
    - **params:**  
    `filepath`: The file path  
    - **returns:**  
    The file type (one of `SafeFs.FILETYPE_*`)  
          - staticmethod: `_gz (file1, file2, overwrite, filetype1, filetype2)`


    Gzip a file or tar gzip a directory  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - staticmethod: `_link (file1, file2, overwrite, filetype1, filetype2)`


    Create a symbolic link for the given file  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `_lock (self, lock1, lock2)`


    Lock the file slots  
    - **params:**  
    `lock1`: Which slots to lock for file1  
    - `both`: Both the file itself and the realpath of it (if it is a link)  
    - `real`: Only the realpath of it  
    - `self`: Just the file itself  
    `lock2`: Which slots to lock for file2  
          - staticmethod: `_lockfile (filepath, real, filetype, tmpdir)`


    Get the path of lockfile of a file  
    - **params:**  
    `filepath`: The file  
    `real`    : Use the filepath itself or the realpath (if filepath is a link). Default: `True`  
    `filetype`: The filetype, if not provided, will be fetched by `SafeFs._filetype`  
    `tmpdir`  : The tmpdir storing the lock files.  
    - **returns:**  
    The path of the lock file  
          - staticmethod: `_move (file1, file2, overwrite, filetype1, filetype2)`


    Move a file  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - staticmethod: `_remove (filepath, filetype)`


    Remove an entry  
    - **params:**  
    `filepath`: The path of the entry  
    `filetype`: The file type  
    - **returns:**  
    `True` if succeed else `False`  
          - staticmethod: `_ungz (file1, file2, overwrite, filetype1, filetype2)`


    Decompress a gzip file or tar-gzip file  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `_unlock (self)`


    Unlock the slots  
          - staticmethod: `basename (filepath)`


    Get the basename of a file  
    If it is a directory like '/a/b/c/', return `c`  
    - **params:**  
    `filepath`: The file path  
    - **returns:**  
    The basename  
          - method: `chmodX (self)`


    Convert file1 to executable or add extract shebang to cmd line  
    - **returns:**  
    A list with or without the path of the interpreter as the first element and the script file as the last element  
          - method: `copy (self, overwrite, callback)`


    Copy file1 to file2 thread-safely  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `exists (self, callback)`


    Tell if file1 exists thread-safely  
    - **params:**  
    `callback`: The callback. arguments:  
    - `r` : Whether the file exists  
    - `fs`: This instance  
    - **returns:**  
    `True` if exists else `False`  
          - method: `filesig (self, dirsig)`


    Generate a signature for a file  
    - **params:**  
    `dirsig`: Whether expand the directory? Default: True  
    - **returns:**  
    The signature  
          - staticmethod: `flush (fd, lastmsg, end)`


    Flush a file descriptor  
    - **params:**  
    `fd`     : The file handler  
    `lastmsg`: The remaining content of last flush  
    `end`    : The file ends? Default: `False`  
          - method: `gz (self, overwrite, callback)`


    Gzip file1 (tar-gzip if file1 is a directory) to file2 in a thread-safe way  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `link (self, overwrite, callback)`


    Link file1 to file2 thread-safely  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `move (self, overwrite, callback)`


    Move file1 to file2 thread-safely  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `moveWithLink (self, overwrite, callback)`


    Move file1 to file2 and link file2 to file1 in a thread-safe way  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `remove (self, callback)`


    Remove file1 thread-safely  
    - **params:**  
    `callback`: The callback. arguments:  
    - `r` : Whether the file exists  
    - `fs`: This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `samefile (self, callback)`


    Tell if file1 and file2 are the same file in a thread-safe way  
    - **params:**  
    `callback`: The callback. arguments:  
    - `r` : Whether the file exists  
    - `fs`: This instance  
    - **returns:**  
    `True` if they are the same file else `False`  
          - method: `ungz (self, overwrite, callback)`


    Ungzip file1 (tar-ungzip if file1 tar-gzipped to file2 in a thread-safe way  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
      # module: pyppl.runners.runner
</code></pre>
<p>The base runner class<br />
  !!! hint class: <code>Runner</code></p>
<pre><code>The base runner class  
      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      !!! hint function: `Lock ()`


Returns a non-recursive lock object  
  !!! hint function: `Value (typecode_or_type, *args, **kwds)`


Returns a synchronized shared object  
  !!! hint function: `list2cmdline (seq)`


Translate a sequence of arguments into a command line  
string, using the same rules as the MS C runtime:

1) Arguments are delimited by white space, which is either a  
space or a tab.

2) A string surrounded by double quotation marks is  
interpreted as a single argument, regardless of white space  
contained within.  A quoted string can be embedded in an  
argument.

3) A double quotation mark preceded by a backslash is  
interpreted as a literal double quotation mark.

4) Backslashes are interpreted literally, unless they  
immediately precede a double quotation mark.

5) If backslashes immediately precede a double quotation mark,  
every pair of backslashes is interpreted as a literal  
backslash.  If the number of backslashes is odd, the last  
backslash escapes the next double quotation mark as  
described in rule 3.  
  # module: pyppl.runners.runner_dry
</code></pre>
<h2 id="dry-runner">Dry runner</h2>
<p>!!! hint class: <code>Runner</code></p>
<pre><code>The base runner class  
      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      !!! hint class: `RunnerDry`


The dry runner  
      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`


    Do some cleanup work when jobs finish  
          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      # module: pyppl.runners.runner_local
</code></pre>
<h2 id="a-runner-wrapper-for-a-single-script">A runner wrapper for a single script</h2>
<h2 id="author-pwwangpwwangcom">Author: pwwang@pwwang.com</h2>
<h2 id="examples">Examples:</h2>
<h2 id="see-runnerunittestpy">@see runner.unittest.py</h2>
<p>!!! hint class: <code>Runner</code></p>
<pre><code>The base runner class  
      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      !!! hint class: `RunnerLocal`


Constructor  
- **params:**  
`job`:    The job object  
`config`: The properties of the process  
      - method: `__init__ (self, job)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      # module: pyppl.runners.runner_sge
</code></pre>
<p>!!! hint class: <code>Runner</code></p>
<pre><code>The base runner class  
      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      !!! hint class: `RunnerSge`


The sge runner  
      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
    `config`: The properties of the process  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      # module: pyppl.runners.runner_slurm
</code></pre>
<p>!!! hint class: <code>Runner</code></p>
<pre><code>The base runner class  
      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      !!! hint class: `RunnerSlurm`


The slurm runner  
      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
    `config`: The properties of the process  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      # module: pyppl.runners.runner_ssh
</code></pre>
<p>!!! hint class: <code>Runner</code></p>
<pre><code>The base runner class  
      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      !!! hint function: `Lock ()`


Returns a non-recursive lock object  
  !!! hint function: `Value (typecode_or_type, *args, **kwds)`


Returns a synchronized shared object  
  !!! hint class: `RunnerSsh`


The ssh runner

- **static variables:**  
`SERVERID`: The incremental number used to calculate which server should be used.  
- Don't touch unless you know what's going on!

      - method: `__init__ (self, job)`


    Constructor  
    - **params:**  
    `job`:    The job object  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `_flush (self, fout, ferr, lastout, lasterr, end)`


    Flush stdout/stderr  
    - **params:**  
    `fout`: The stdout file handler  
    `ferr`: The stderr file handler  
    `lastout`: The leftovers of previously readlines of stdout  
    `lasterr`: The leftovers of previously readlines of stderr  
    `end`: Whether this is the last time to flush  
          - method: `finish (self)`

          - method: `getpid (self)`


    Get the job id  
          - method: `isRunning (self)`


    Try to tell whether the job is still running.  
    - **returns:**  
    `True` if yes, otherwise `False`  
          - staticmethod: `isServerAlive (server, key)`

          - method: `kill (self)`


    Try to kill the running jobs if I am exiting  
          - method: `retry (self)`

          - method: `run (self)`


    - **returns:**  
    True: success/fail  
    False: needs retry  
          - method: `submit (self)`


    Try to submit the job  
      !!! hint function: `Array (typecode_or_type, size_or_initializer, **kwds)`


Returns a synchronized shared array  
  !!! hint class: `RunnerSshError`


Raise when failed to initiate RunnerSsh  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  # module: pyppl.templates.template
</code></pre>
<p>!!! hint function: <code>asStr (s, encoding)</code></p>
<pre><code>Convert everything (str, unicode, bytes) to str with python2, python3 compatiblity  
  # module: pyppl.templates.template_jinja2
</code></pre>
<p>!!! hint class: <code>TemplateJinja2</code></p>
<pre><code>Jinja2 template wrapper  
      - method: `__init__ (self, source, **envs)`


    Initiate the engine with source and envs  
    - **params:**  
    `source`: The souce text  
    `envs`: The env data  
          - method: `__repr__ (self)`

          - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ (self)`

          - method: `_render (self, data)`


    Render the template  
    - **params:**  
    `data`: The data used for rendering  
    - **returns:**  
    The rendered string  
          - method: `registerEnvs (self, **envs)`

          - method: `render (self, data)`

      # module: pyppl.templates.template_pyppl
</code></pre>
<p>This template engine is borrowed from Templite<br />
The code is here: https://github.com/aosabook/500lines/blob/master/template-engine/code/templite.py<br />
Author: Ned Batchelder<br />
Project: Template engine<br />
Requirements: Python  </p>
<p>Modified by: pwwang<br />
Functions added:<br />
- support elif, else<br />
- support for dict: for k,v in dict.items()<br />
- support [] to get element from list or dict.<br />
- support multivariables in expression:<br />
{{d1,d2|concate}}<br />
{'concate': lambda x,y: x+y}<br />
  !!! hint class: <code>TemplatePyPPLLine</code></p>
<pre><code>Line of compiled code  
      - method: `__init__ (self, line, src, indent)`


    Constructor of line  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ (self)`

      !!! hint class: `TemplatePyPPLRenderError`


Failed to render a template  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, stack, src)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `TemplatePyPPL`


Built-in template wrapper.  
      - method: `__init__ (self, source, **envs)`


    Initiate the engine with source and envs  
    - **params:**  
    `source`: The souce text  
    `envs`: The env data  
          - method: `__repr__ (self)`

          - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ (self)`

          - method: `_render (self, data)`


    Render the template  
    - **params:**  
    `data`: The data used for rendering  
    - **returns:**  
    The rendered string  
          - method: `registerEnvs (self, **envs)`

          - method: `render (self, data)`

      !!! hint class: `TemplatePyPPLSyntaxError`


Raised when a template has a syntax error.  
      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ (self, name, src, msg)`

          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint class: `TemplatePyPPLEngine`

A simple template renderer, for a nano-subset of Django syntax.  
Supported constructs are extended variable access::  
{{var.modifer.modifier|filter|filter}}  
loops::  
{% for var in list %}...{% endfor %}  
and ifs::  
{% if var %}...{% endif %}  
Comments are within curly-hash markers::  
{# This will be ignored #}  
Construct a Templite with the template text, then use `render` against a  
dictionary context to create a finished string::  
templite = Templite('''  
&lt;h1&gt;Hello {{name|upper}}!&lt;/h1&gt;  
{% for topic in topics %}  
&lt;p&gt;You are interested in {{topic}}.&lt;/p&gt;  
{% endif %}  
''',  
{'upper': str.upper},  
)  
text = templite.render({  
'name': "Ned",  
'topics': ['Python', 'Geometry', 'Juggling'],  
})  
      - method: `__init__ (self, text, *contexts)`


    Construct a Templite with the given `text`.  
    `contexts` are dictionaries of values to use for future renderings.  
    These are good for filters and global values.  
    - **params:**  
    `text`: The template text  
    `contexts`: The contexts used to render.  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ (self)`


    Stringize the engine.  
    - **returns:**  
    The string of the stringized engine.  
          - staticmethod: `_do_dots (value, *dots)`


    Evaluate dotted expressions at runtime.  
    - **params:**  
    `value`: The value  
    `dots`:  The set of dots to do one after another  
    - **returns:**  
    The value after dots being done  
          - method: `_exprCode (self, expr, src)`


    Generate a Python expression for `expr`.  
    - **params:**  
    `expr`: The expression  
    `src`:  The source of the expression  
    - **returns:**  
    The code after the expression being parsed.  
          - method: `_parseComments (self, token, src)`

          - method: `_parseExpression (self, token, src)`

          - method: `_parseLiteral (self, tokenlines, src)`

          - method: `_parseTag (self, token, src, ops_stack)`

          - staticmethod: `_variable (name, src, vars_set)`


    Track that `name` is used as a variable.  
    Adds the name to `vars_set`, a set of variable names.  
    Raises an syntax error if `name` is not a valid name.  
    - **params:**  
    `name`: The name of the variable  
    `src`:  The source of the variable  
    `vars_set`: The variable set  
          - method: `flushOutput (self)`


    Force `self.buffered` to the code builder.  
    - **params:**  
    `code`: The code builder  
          - method: `render (self, context)`


    Render this template by applying it to `context`.  
    - **params:**  
    `context`: a dictionary of values to use in this rendering.  
    - **returns:**  
    The rendered string  
      !!! hint class: `TemplatePyPPLCodeBuilder`


Build source code conveniently.  
      - method: `__init__ (self, envs, indent)`


    Constructor of code builder  
    - **params:**  
    indent: The initial indent level  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ (self)`


    Concatnate of the codes  
    - **returns:**  
    The concatnated string  
          - method: `_nlines (self)`


    Get the number of lines in the builder  
    - **returns:**  
    The number of lines.  
          - method: `addLine (self, line, src)`


    Add a line of source to the code.  
    Indentation and newline will be added for you, don't provide them.  
    - **params:**  
    line: The line to add  
          - method: `addSection (self)`


    Add a section, a sub-CodeBuilder.  
    - **returns:**  
    The section added.  
          - method: `dedent (self)`


    Decrease the current indent for following lines.  
          - method: `getGlobals (self)`


    Execute the code, and return a dict of globals it defines.  
          - method: `indent (self)`


    Increase the current indent for following lines.  
          - method: `lineByNo (self, lineno)`


    Get the line by line number  
    - **params:**  
    `lineno`: The line number  
    - **returns:**  
    The TemplatePyPPLLine object at `lineno`.  
      # module: pyppl.utils
</code></pre>
<p>A set of utitities for PyPPL<br />
  !!! hint function: <code>uid (s, l, alphabet)</code></p>
<pre><code>Calculate a short uid based on a string.  
Safe enough, tested on 1000000 32-char strings, no repeated uid found.  
This is used to calcuate a uid for a process  
- **params:**  
`s`: the base string  
`l`: the length of the uid  
`alphabet`: the charset used to generate the uid  
- **returns:**  
The uid  
  !!! hint function: `reduce (func, vec)`


Python2 and Python3 compatible reduce  
- **params:**  
`func`: The reduce function  
`vec`: The list to be reduced  
- **returns:**  
The reduced value  
  !!! hint function: `funcsig (func)`


Get the signature of a function  
Try to get the source first, if failed, try to get its name, otherwise return None  
- **params:**  
`func`: The function  
- **returns:**  
The signature  
  !!! hint function: `alwaysList (data)`


Convert a string or a list with element  
- **params:**  
`data`: the data to be converted  
- **examples:**  
```python  
data = ["a, b, c", "d"]  
ret  = alwaysList (data)  
# ret == ["a", "b", "c", "d"]  
```  
- **returns:**  
The split list  
  !!! hint function: `formatSecs (seconds)`


Format a time duration  
- **params:**  
`seconds`: the time duration in seconds  
- **returns:**  
The formated string.  
For example: "01:01:01.001" stands for 1 hour 1 min 1 sec and 1 minisec.  
  !!! hint function: `split (s, delimter, trim)`


Split a string using a single-character delimter  
- **params:**  
`s`: the string  
`delimter`: the single-character delimter  
`trim`: whether to trim each part. Default: True  
- **examples:**  
```python  
ret = split("'a,b',c", ",")  
# ret == ["'a,b'", "c"]  
# ',' inside quotes will be recognized.  
```  
- **returns:**  
The list of substrings  
  !!! hint function: `briefList (l)`


Briefly show an integer list, combine the continuous numbers.  
- **params:**  
`l`: The list  
- **returns:**  
The string to show for the briefed list.  
  !!! hint class: `Box`


Allow dot operation for OrderedDict  
      - method: `_OrderedDict__update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `__cmp__ ()`

    x.__cmp__(y) &lt;==&gt; cmp(x,y)      - method: `__contains__ ()`

    D.__contains__(k) -&gt; True if D has a key k, else False      - method: `__delitem__ (self, key, dict_delitem)`

    od.__delitem__(y) &lt;==&gt; del od[y]      - method: `__ge__ ()`

    x.__ge__(y) &lt;==&gt; x&gt;=y      - method: `__getattr__ (self, name)`

          - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__gt__ ()`

    x.__gt__(y) &lt;==&gt; x&gt;y      - method: `__init__ (*args, **kwds)`

    Initialize an ordered dictionary.  The signature is the same as  
    regular dictionaries, but keyword arguments are not recommended because  
    their insertion order is arbitrary.

          - method: `__iter__ (self)`

    od.__iter__() &lt;==&gt; iter(od)      - method: `__le__ ()`

    x.__le__(y) &lt;==&gt; x&lt;=y      - method: `__len__ ()`

    x.__len__() &lt;==&gt; len(x)      - method: `__lt__ ()`

    x.__lt__(y) &lt;==&gt; x&lt;y      - method: `__repr__ (self, _repr_running)`

    od.__repr__() &lt;==&gt; repr(od)      - method: `__reversed__ (self)`

    od.__reversed__() &lt;==&gt; reversed(od)      - method: `__setattr__ (self, name, val)`

          - method: `__setitem__ (self, key, value, dict_setitem)`

    od.__setitem__(i, y) &lt;==&gt; od[i]=y      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `clear (self)`

    od.clear() -&gt; None.  Remove all items from od.      - method: `copy (self)`

    od.copy() -&gt; a shallow copy of od      - method: `fromkeys (cls, iterable, value)`

    OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.  
    If not specified, the value defaults to None.

          - method: `get ()`

    D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.      - method: `has_key ()`

    D.has_key(k) -&gt; True if D has a key k, else False      - method: `items (self)`

    od.items() -&gt; list of (key, value) pairs in od      - method: `iteritems (self)`

    od.iteritems -&gt; an iterator over the (key, value) pairs in od      - method: `iterkeys (self)`

    od.iterkeys() -&gt; an iterator over the keys in od      - method: `itervalues (self)`

    od.itervalues -&gt; an iterator over the values in od      - method: `keys (self)`

    od.keys() -&gt; list of keys in od      - method: `pop (self, key, default)`

    od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding  
    value.  If key is not found, d is returned if given, otherwise KeyError  
    is raised.

          - method: `popitem (self, last)`

    od.popitem() -&gt; (k, v), return and remove a (key, value) pair.  
    Pairs are returned in LIFO order if last is true or FIFO order if false.

          - method: `setdefault (self, key, default)`

    od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od      - method: `update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `values (self)`

    od.values() -&gt; list of values in od      - method: `viewitems (self)`

    od.viewitems() -&gt; a set-like object providing a view on od's items      - method: `viewkeys (self)`

    od.viewkeys() -&gt; a set-like object providing a view on od's keys      - method: `viewvalues (self)`

    od.viewvalues() -&gt; an object providing a view on od's values  !!! hint function: `map (func, vec)`


Python2 and Python3 compatible map  
- **params:**  
`func`: The map function  
`vec`: The list to be maped  
- **returns:**  
The maped list  
  !!! hint function: `varname (maxline, incldot)`


Get the variable name for ini  
- **params:**  
`maxline`: The max number of lines to retrive. Default: 20  
`incldot`: Whether include dot in the variable name. Default: False  
- **returns:**  
The variable name  
  !!! hint function: `filter (func, vec)`


Python2 and Python3 compatible filter  
- **params:**  
`func`: The filter function  
`vec`:  The list to be filtered  
- **returns:**  
The filtered list  
  !!! hint function: `dictUpdate (origDict, newDict)`


Update a dictionary recursively.  
- **params:**  
`origDict`: The original dictionary  
`newDict`:  The new dictionary  
- **examples:**  
```python  
od1 = {"a": {"b": {"c": 1, "d":1}}}  
od2 = {key:value for key:value in od1.items()}  
nd  = {"a": {"b": {"d": 2}}}  
od1.update(nd)  
# od1 == {"a": {"b": {"d": 2}}}, od1["a"]["b"] is lost  
dictUpdate(od2, nd)  
# od2 == {"a": {"b": {"c": 1, "d": 2}}}  
```  
  !!! hint function: `range (i, *args, **kwargs)`


Convert a range to list, because in python3, range is not a list  
- **params:**  
`r`: the range data  
- **returns:**  
The converted list  
  !!! hint function: `asStr (s, encoding)`


Convert everything (str, unicode, bytes) to str with python2, python3 compatiblity  
  # module: pyppl.utils.box
</code></pre>
<p>!!! hint class: <code>Box</code></p>
<pre><code>Allow dot operation for OrderedDict  
      - method: `_OrderedDict__update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `__cmp__ ()`

    x.__cmp__(y) &lt;==&gt; cmp(x,y)      - method: `__contains__ ()`

    D.__contains__(k) -&gt; True if D has a key k, else False      - method: `__delitem__ (self, key, dict_delitem)`

    od.__delitem__(y) &lt;==&gt; del od[y]      - method: `__ge__ ()`

    x.__ge__(y) &lt;==&gt; x&gt;=y      - method: `__getattr__ (self, name)`

          - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__gt__ ()`

    x.__gt__(y) &lt;==&gt; x&gt;y      - method: `__init__ (*args, **kwds)`

    Initialize an ordered dictionary.  The signature is the same as  
    regular dictionaries, but keyword arguments are not recommended because  
    their insertion order is arbitrary.

          - method: `__iter__ (self)`

    od.__iter__() &lt;==&gt; iter(od)      - method: `__le__ ()`

    x.__le__(y) &lt;==&gt; x&lt;=y      - method: `__len__ ()`

    x.__len__() &lt;==&gt; len(x)      - method: `__lt__ ()`

    x.__lt__(y) &lt;==&gt; x&lt;y      - method: `__repr__ (self, _repr_running)`

    od.__repr__() &lt;==&gt; repr(od)      - method: `__reversed__ (self)`

    od.__reversed__() &lt;==&gt; reversed(od)      - method: `__setattr__ (self, name, val)`

          - method: `__setitem__ (self, key, value, dict_setitem)`

    od.__setitem__(i, y) &lt;==&gt; od[i]=y      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `clear (self)`

    od.clear() -&gt; None.  Remove all items from od.      - method: `copy (self)`

    od.copy() -&gt; a shallow copy of od      - method: `fromkeys (cls, iterable, value)`

    OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.  
    If not specified, the value defaults to None.

          - method: `get ()`

    D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.      - method: `has_key ()`

    D.has_key(k) -&gt; True if D has a key k, else False      - method: `items (self)`

    od.items() -&gt; list of (key, value) pairs in od      - method: `iteritems (self)`

    od.iteritems -&gt; an iterator over the (key, value) pairs in od      - method: `iterkeys (self)`

    od.iterkeys() -&gt; an iterator over the keys in od      - method: `itervalues (self)`

    od.itervalues -&gt; an iterator over the values in od      - method: `keys (self)`

    od.keys() -&gt; list of keys in od      - method: `pop (self, key, default)`

    od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding  
    value.  If key is not found, d is returned if given, otherwise KeyError  
    is raised.

          - method: `popitem (self, last)`

    od.popitem() -&gt; (k, v), return and remove a (key, value) pair.  
    Pairs are returned in LIFO order if last is true or FIFO order if false.

          - method: `setdefault (self, key, default)`

    od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od      - method: `update (*args, **kwds)`

    D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
    If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
    If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
    In either case, this is followed by: for k, v in F.items(): D[k] = v  
          - method: `values (self)`

    od.values() -&gt; list of values in od      - method: `viewitems (self)`

    od.viewitems() -&gt; a set-like object providing a view on od's items      - method: `viewkeys (self)`

    od.viewkeys() -&gt; a set-like object providing a view on od's keys      - method: `viewvalues (self)`

    od.viewvalues() -&gt; an object providing a view on od's values  # module: pyppl.utils.cmd
</code></pre>
<p>!!! hint function: <code>run (cmd, bg, raiseExc, timeout, **kwargs)</code></p>
<pre><code>A shortcut of `Command.run`  
To chain another command, you can do:  
`run('seq 1 3', bg = True).pipe('grep 1')`  
- **params:**  
`cmd`     : The command, could be a string or a list  
`bg`      : Run in background or not. Default: `False`  
- If it is `True`, `rc` and `stdout/stderr` will be default (no value retrieved).  
`raiseExc`: raise the expcetion or not  
`**kwargs`: other arguments for `Popen`  
- **returns:**  
The `Command` instance  
  !!! hint class: `Cmd`


A command (subprocess) wapper  
      - method: `__init__ (self, cmd, raiseExc, timeout, **kwargs)`


    Constructor  
    - **params:**  
    `cmd`     : The command, could be a string or a list  
    `raiseExc`: raise the expcetion or not  
    `**kwargs`: other arguments for `Popen`  
          - method: `__repr__ (self)`

          - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `pipe (self, cmd, **kwargs)`


    Pipe another command  
    - **examples:**  
    ```python  
    c = Command('seq 1 3').pipe('grep 1').run()  
    c.stdout == '1  
    '  
    ```  
    - **params:**  
    `cmd`: The other command  
    `**kwargs`: Other arguments for `Popen` for the other command  
    - **returns:**  
    `Command` instance of the other command  
          - method: `run (self, bg)`


    Wait for the command to run  
    - **params:**  
    `bg`: Run in background or not. Default: `False`  
    - If it is `True`, `rc` and `stdout/stderr` will be default (no value retrieved).  
    - **returns:**  
    `self`  
      # module: pyppl.utils.parallel
</code></pre>
<p>!!! hint function: <code>run (func, args, nthread, backend, raiseExc)</code></p>
<pre><code>A shortcut of `Parallel.run`  
- **params:**  
`func`    : The function to run  
`args`    : The arguments for the function, should be a `list` with `tuple`s  
`nthread` : Number of jobs to run simultaneously. Default: `1`  
`backend` : The backend, either `process` (default) or `thread`  
`raiseExc`: Whether raise exception or not. Default: `True`  
- **returns:**  
The merged results from each job.  
  !!! hint class: `Parallel`


A parallel runner  
      - method: `__init__ (self, nthread, backend, raiseExc)`


    Constructor  
    - **params:**  
    `nthread` : Number of jobs to run simultaneously. Default: `1`  
    `backend` : The backend, either `process` (default) or `thread`  
    `raiseExc`: Whether raise exception or not. Default: `True`  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `run (self, func, args)`


    Run parallel jobs  
    - **params:**  
    `func`    : The function to run  
    `args`    : The arguments for the function, should be a `list` with `tuple`s  
    `nthread` : Number of jobs to run simultaneously. Default: `1`  
    `backend` : The backend, either `process` (default) or `thread`  
    `raiseExc`: Whether raise exception or not. Default: `True`  
    - **returns:**  
    The merged results from each job.  
      # module: pyppl.utils.ps
</code></pre>
<p>!!! hint function: <code>exists (pid)</code></p>
<pre><code>Check whether pid exists in the current process table.  
From https://github.com/kennethreitz/delegator.py/blob/master/delegator.py  
  !!! hint class: `Cmd`


A command (subprocess) wapper  
      - method: `__init__ (self, cmd, raiseExc, timeout, **kwargs)`


    Constructor  
    - **params:**  
    `cmd`     : The command, could be a string or a list  
    `raiseExc`: raise the expcetion or not  
    `**kwargs`: other arguments for `Popen`  
          - method: `__repr__ (self)`

          - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - method: `pipe (self, cmd, **kwargs)`


    Pipe another command  
    - **examples:**  
    ```python  
    c = Command('seq 1 3').pipe('grep 1').run()  
    c.stdout == '1  
    '  
    ```  
    - **params:**  
    `cmd`: The other command  
    `**kwargs`: Other arguments for `Popen` for the other command  
    - **returns:**  
    `Command` instance of the other command  
          - method: `run (self, bg)`


    Wait for the command to run  
    - **params:**  
    `bg`: Run in background or not. Default: `False`  
    - If it is `True`, `rc` and `stdout/stderr` will be default (no value retrieved).  
    - **returns:**  
    `self`  
      !!! hint function: `child (pid, pidlist)`


Direct children  
  # module: pyppl.utils.safefs
</code></pre>
<p>!!! hint function: <code>copyfile (src, dst)</code></p>
<pre><code>Copy data from src to dst  !!! hint function: `exists (filepath, callback)`


A shortcut of `SafeFs.exists`  
- **params:**  
`filepath`: The filepath  
`callback`: The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  
- **returns:**  
`True` if the file exists else `False`  
  !!! hint function: `move (file1, file2, overwrite, callback)`


A shortcut of `SafeFs.move`  
- **params:**  
`file1`    : File 1  
`file2`    : File 2  
`overwrite`: Whether overwrite file 2. Default: `True`  
`callback` : The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  
- **returns:**  
`True` if succeed else `False`  
  !!! hint function: `gz (file1, file2, overwrite, callback)`


A shortcut of `SafeFs.gz`  
- **params:**  
`file1`    : File 1  
`file2`    : File 2  
`overwrite`: Whether overwrite file 2. Default: `True`  
`callback` : The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  
- **returns:**  
`True` if succeed else `False`  
  !!! hint function: `walk (top, topdown, onerror, followlinks)`

Directory tree generator.

For each directory in the directory tree rooted at top (including top  
itself, but excluding '.' and '..'), yields a 3-tuple

dirpath, dirnames, filenames

dirpath is a string, the path to the directory.  dirnames is a list of  
the names of the subdirectories in dirpath (excluding '.' and '..').  
filenames is a list of the names of the non-directory files in dirpath.  
Note that the names in the lists are just names, with no path components.  
To get a full path (which begins with top) to a file or directory in  
dirpath, do os.path.join(dirpath, name).

If optional arg 'topdown' is true or not specified, the triple for a  
directory is generated before the triples for any of its subdirectories  
(directories are generated top down).  If topdown is false, the triple  
for a directory is generated after the triples for all of its  
subdirectories (directories are generated bottom up).

When topdown is true, the caller can modify the dirnames list in-place  
(e.g., via del or slice assignment), and walk will only recurse into the  
subdirectories whose names remain in dirnames; this can be used to prune the  
search, or to impose a specific order of visiting.  Modifying dirnames when  
topdown is false is ineffective, since the directories in dirnames have  
already been generated by the time dirnames itself is generated. No matter  
the value of topdown, the list of subdirectories is retrieved before the  
tuples for the directory and its subdirectories are generated.

By default errors from the os.listdir() call are ignored.  If  
optional arg 'onerror' is specified, it should be a function; it  
will be called with one argument, an os.error instance.  It can  
report the error to continue with the walk, or raise the exception  
to abort the walk.  Note that the filename is available as the  
filename attribute of the exception object.

By default, os.walk does not follow symbolic links to subdirectories on  
systems that support them.  In order to get this functionality, set the  
optional argument 'followlinks' to true.

Caution:  if you pass a relative pathname for top, don't change the  
current working directory between resumptions of walk.  walk never  
changes the current directory, and assumes that the client doesn't  
either.

Example:

import os  
from os.path import join, getsize  
for root, dirs, files in os.walk('python/Lib/email'):  
print root, "consumes",  
print sum([getsize(join(root, name)) for name in files]),  
print "bytes in", len(files), "non-directory files"  
if 'CVS' in dirs:  
dirs.remove('CVS')  # don't visit CVS directories

  !!! hint class: `SafeFs`


A thread-safe file system

- **static variables:**

`TMPDIR`: The default temporary directory to store lock files

# file types  
`FILETYPE_UNKNOWN`  : Unknown file type  
`FILETYPE_NOENT`    : File does not exist  
`FILETYPE_NOENTLINK`: A dead link (a link links to a non-existent file.  
`FILETYPE_FILE`     : A regular file  
`FILETYPE_FILELINK` : A link to a regular file  
`FILETYPE_DIR`      : A regular directory  
`FILETYPE_DIRLINK`  : A link to a regular directory

# relation of two files  
`FILES_DIFF_BOTHNOENT` : Two files are different and none of them exists  
`FILES_DIFF_NOENT1`    : Two files are different but file1 does not exists  
`FILES_DIFF_NOENT2`    : Two files are different but file2 does not exists  
`FILES_DIFF_BOTHENT`   : Two files are different and both of them exist  
`FILES_SAME_STRNOENT`  : Two files are the same string and it does not exist  
`FILES_SAME_STRENT`    : Two files are the same string and it exists  
`FILES_SAME_BOTHLINKS` : Two files link to one file  
`FILES_SAME_BOTHLINKS1`: File1 links to file2, file2 links to a regular file  
`FILES_SAME_BOTHLINKS2`: File2 links to file1, file1 links to a regular file  
`FILES_SAME_REAL1`     : File2 links to file1, which a regular file  
`FILES_SAME_REAL2`     : File1 links to file2, which a regular file

`LOCK`: A global lock ensures the locks are locked at the same time  
      - method: `__init__ (self, file1, file2, tmpdir)`


    Constructor  
    - **params:**  
    `file1`:  File 1  
    `file2`:  File 2. Default: `None`  
    `tmpdir`: The temporary directory used to store lock files. Default: `None` (`SafeFs.TMPDIR`)  
          - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)      - staticmethod: `_copy (file1, file2, overwrite, filetype1, filetype2)`


    Copy a file or a directory  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - staticmethod: `_dirmtime (filepath)`


    Get the modified time of a directory recursively  
    - **params:**  
    `filepath`: The file path  
    - **return`:**  
    The most recent modified time  
          - staticmethod: `_exists (filepath, filetype)`


    Tell if a file exists  
    - **params:**  
    `filepath`: The source  
    `filetype`: The file type of file2  
    - **returns:**  
    `True` if exists else `False`  
          - staticmethod: `_filerel (file1, file2, filetype1, filetype2)`


    Check the relations between file1 and file2.  
    - **params:**  
    `file1`: The first file  
    `file2`: The second file  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `SafeFs.FILES_DIFF_BOTHNOENT`: they are different for whatever reason.  
    `SafeFs.FILES_DIFF_NOENT1`   : they are different for whatever reason.  
    `SafeFs.FILES_DIFF_NOENT2`   : they are different for whatever reason.  
    `SafeFs.FILES_DIFF_BOTHENT`  : they are different for whatever reason.  
    `SafeFs.FILES_SAME_STRENT`   : they are the same string and the file exists.  
    `SafeFs.FILES_SAME_STRNOENT` : they are the same string but the file doesn't exist.  
    `SafeFs.FILES_SAME_BOTHLINKS`: both of them are links to the same file.  
    `SafeFs.FILES_SAME_REAL1`    : file1 is the real file, file2 is a link to it.  
    `SafeFs.FILES_SAME_REAL2`    : file2 is the real file, file1 is a link to it.  
          - staticmethod: `_filetype (filepath)`


    Get the file type  
    - **params:**  
    `filepath`: The file path  
    - **returns:**  
    The file type (one of `SafeFs.FILETYPE_*`)  
          - staticmethod: `_gz (file1, file2, overwrite, filetype1, filetype2)`


    Gzip a file or tar gzip a directory  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - staticmethod: `_link (file1, file2, overwrite, filetype1, filetype2)`


    Create a symbolic link for the given file  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `_lock (self, lock1, lock2)`


    Lock the file slots  
    - **params:**  
    `lock1`: Which slots to lock for file1  
    - `both`: Both the file itself and the realpath of it (if it is a link)  
    - `real`: Only the realpath of it  
    - `self`: Just the file itself  
    `lock2`: Which slots to lock for file2  
          - staticmethod: `_lockfile (filepath, real, filetype, tmpdir)`


    Get the path of lockfile of a file  
    - **params:**  
    `filepath`: The file  
    `real`    : Use the filepath itself or the realpath (if filepath is a link). Default: `True`  
    `filetype`: The filetype, if not provided, will be fetched by `SafeFs._filetype`  
    `tmpdir`  : The tmpdir storing the lock files.  
    - **returns:**  
    The path of the lock file  
          - staticmethod: `_move (file1, file2, overwrite, filetype1, filetype2)`


    Move a file  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - staticmethod: `_remove (filepath, filetype)`


    Remove an entry  
    - **params:**  
    `filepath`: The path of the entry  
    `filetype`: The file type  
    - **returns:**  
    `True` if succeed else `False`  
          - staticmethod: `_ungz (file1, file2, overwrite, filetype1, filetype2)`


    Decompress a gzip file or tar-gzip file  
    - **params:**  
    `file1`    : The source  
    `file2`    : The destination  
    `overwrite`: Overwrite the destination? Default: `True`  
    `filetype1`: The file type of file1  
    `filetype2`: The file type of file2  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `_unlock (self)`


    Unlock the slots  
          - staticmethod: `basename (filepath)`


    Get the basename of a file  
    If it is a directory like '/a/b/c/', return `c`  
    - **params:**  
    `filepath`: The file path  
    - **returns:**  
    The basename  
          - method: `chmodX (self)`


    Convert file1 to executable or add extract shebang to cmd line  
    - **returns:**  
    A list with or without the path of the interpreter as the first element and the script file as the last element  
          - method: `copy (self, overwrite, callback)`


    Copy file1 to file2 thread-safely  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `exists (self, callback)`


    Tell if file1 exists thread-safely  
    - **params:**  
    `callback`: The callback. arguments:  
    - `r` : Whether the file exists  
    - `fs`: This instance  
    - **returns:**  
    `True` if exists else `False`  
          - method: `filesig (self, dirsig)`


    Generate a signature for a file  
    - **params:**  
    `dirsig`: Whether expand the directory? Default: True  
    - **returns:**  
    The signature  
          - staticmethod: `flush (fd, lastmsg, end)`


    Flush a file descriptor  
    - **params:**  
    `fd`     : The file handler  
    `lastmsg`: The remaining content of last flush  
    `end`    : The file ends? Default: `False`  
          - method: `gz (self, overwrite, callback)`


    Gzip file1 (tar-gzip if file1 is a directory) to file2 in a thread-safe way  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `link (self, overwrite, callback)`


    Link file1 to file2 thread-safely  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `move (self, overwrite, callback)`


    Move file1 to file2 thread-safely  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `moveWithLink (self, overwrite, callback)`


    Move file1 to file2 and link file2 to file1 in a thread-safe way  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `remove (self, callback)`


    Remove file1 thread-safely  
    - **params:**  
    `callback`: The callback. arguments:  
    - `r` : Whether the file exists  
    - `fs`: This instance  
    - **returns:**  
    `True` if succeed else `False`  
          - method: `samefile (self, callback)`


    Tell if file1 and file2 are the same file in a thread-safe way  
    - **params:**  
    `callback`: The callback. arguments:  
    - `r` : Whether the file exists  
    - `fs`: This instance  
    - **returns:**  
    `True` if they are the same file else `False`  
          - method: `ungz (self, overwrite, callback)`


    Ungzip file1 (tar-ungzip if file1 tar-gzipped to file2 in a thread-safe way  
    - **params:**  
    `overwrite`: Allow overwrting file2? Default: `True`  
    `callback`:  The callback. arguments:  
    - `r` :  Whether the file exists  
    - `fs`:  This instance  
    - **returns:**  
    `True` if succeed else `False`  
      !!! hint function: `copytree (src, dst, symlinks, ignore)`

Recursively copy a directory tree using copy2().

The destination directory must not already exist.  
If exception(s) occur, an Error is raised with a list of reasons.

If the optional symlinks flag is true, symbolic links in the  
source tree result in symbolic links in the destination tree; if  
it is false, the contents of the files pointed to by symbolic  
links are copied.

The optional ignore argument is a callable. If given, it  
is called with the `src` parameter, which is the directory  
being visited by copytree(), and `names` which is the list of  
`src` contents, as returned by os.listdir():

callable(src, names) -&gt; ignored_names

Since copytree() is called recursively, the callable will be  
called once for each directory that is copied. It returns a  
list of names relative to the `src` directory that should  
not be copied.

XXX Consider this example code rather than the ultimate tool.

  !!! hint function: `copyfileobj (fsrc, fdst, length)`

copy data from file-like object fsrc to file-like object fdst  !!! hint class: `ChmodError`

OS system call failed.      - method: `__getitem__ ()`

    x.__getitem__(y) &lt;==&gt; x[y]      - method: `__init__ ()`

    x.__init__(...) initializes x; see help(type(x)) for signature      - method: `__repr__ ()`

    x.__repr__() &lt;==&gt; repr(x)      - method: `__setattr__ ()`

    x.__setattr__('name', value) &lt;==&gt; x.name = value      - method: `__str__ ()`

    x.__str__() &lt;==&gt; str(x)  !!! hint function: `ungz (file1, file2, overwrite, callback)`


A shortcut of `SafeFs.ungz`  
- **params:**  
`file1`    : File 1  
`file2`    : File 2  
`overwrite`: Whether overwrite file 2. Default: `True`  
`callback` : The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  
- **returns:**  
`True` if succeed else `False`  
  !!! hint function: `shmove (src, dst)`

Recursively move a file or directory to another location. This is  
similar to the Unix "mv" command.

If the destination is a directory or a symlink to a directory, the source  
is moved inside the directory. The destination path must not already  
exist.

If the destination already exists but is not a directory, it may be  
overwritten depending on os.rename() semantics.

If the destination is on our current filesystem, then rename() is used.  
Otherwise, src is copied to the destination and then removed.  
A lot more could be done here...  A look at a mv.c shows a lot of  
the issues this implementation glosses over.

  !!! hint function: `moveWithLink (file1, file2, overwrite, callback)`


A shortcut of `SafeFs.moveWithLink`  
- **params:**  
`file1`    : File 1  
`file2`    : File 2  
`overwrite`: Whether overwrite file 2. Default: `True`  
`callback` : The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  
- **returns:**  
`True` if succeed else `False`  
  !!! hint function: `link (file1, file2, overwrite, callback)`


A shortcut of `SafeFs.link`  
- **params:**  
`file1`    : File 1  
`file2`    : File 2  
`overwrite`: Whether overwrite file 2. Default: `True`  
`callback` : The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  
- **returns:**  
`True` if succeed else `False`  
  !!! hint function: `copy (file1, file2, overwrite, callback)`


A shortcut of `SafeFs.copy`  
- **params:**  
`file1`    : File 1  
`file2`    : File 2  
`overwrite`: Whether overwrite file 2. Default: `True`  
`callback` : The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  
- **returns:**  
`True` if succeed else `False`  
  !!! hint function: `Lock ()`


Returns a non-recursive lock object  
  !!! hint function: `remove (filepath, callback)`


A shortcut of `SafeFs.remove`  
- **params:**  
`filepath`: The filepath  
`callback`: The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  
- **returns:**  
`True` if succeed else `False`
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../faq/" class="btn btn-neutral float-right" title="FAQ">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../command-line-tool/" class="btn btn-neutral" title="Command line tool"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../command-line-tool/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../faq/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
