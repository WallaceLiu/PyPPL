<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>API - PyPPL</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "API";
    var mkdocs_page_input_path = "api.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> PyPPL</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Introduction</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../basic-concepts-and-directory-structure/">Basics and folder structure</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../placeholders/">Templating</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../channels/">Channels</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../specify-input-and-output-of-a-process/">Input and output of a process</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../write-your-script/">The heart: script</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../export-output-files/">Output file exporting</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../caching/">Caching and resuming processes</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../runners/">Runners and running profiles</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../error-handling/">Error handling of processes</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../set-other-properties-of-a-process/">Other attributes of a process</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../configure-your-logs/">Log configuration</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../draw-flowchart-of-a-pipeline/">Pipeline flowchart</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../configure-a-pipeline/">Pipeline configuration</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../command-line-argument-parser/">Command line argument parser</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../aggregations/">Aggregations</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../command-line-tool/">Command line tool</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">API</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#module-pyppl">+ module: pyppl</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#class-pyppl">class: PyPPL</a></li>
        
            <li><a class="toctree-l3" href="#class-proc">class: Proc</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#module-pypplaggr">+ module: pyppl.aggr</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#class-_proxy">class: _Proxy</a></li>
        
            <li><a class="toctree-l3" href="#class-aggrattributeerror">class: AggrAttributeError</a></li>
        
            <li><a class="toctree-l3" href="#class-aggr">class: Aggr</a></li>
        
            <li><a class="toctree-l3" href="#function-formatsecs-seconds">function: formatSecs (seconds)</a></li>
        
            <li><a class="toctree-l3" href="#function-split-s-delimter-trim">function: split (s, delimter, trim)</a></li>
        
            <li><a class="toctree-l3" href="#function-brieflist-l">function: briefList (l)</a></li>
        
            <li><a class="toctree-l3" href="#class-box">class: Box</a></li>
        
            <li><a class="toctree-l3" href="#function-map-func-vec">function: map (func, vec)</a></li>
        
            <li><a class="toctree-l3" href="#function-varname-maxline-incldot">function: varname (maxline, incldot)</a></li>
        
            <li><a class="toctree-l3" href="#function-filter-func-vec">function: filter (func, vec)</a></li>
        
            <li><a class="toctree-l3" href="#function-dictupdate-origdict-newdict">function: dictUpdate (origDict, newDict)</a></li>
        
            <li><a class="toctree-l3" href="#function-range-i-args-kwargs">function: range (i, *args, **kwargs)</a></li>
        
            <li><a class="toctree-l3" href="#function-asstr-s-encoding">function: asStr (s, encoding)</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#module-pypplutilsbox">+ module: pyppl.utils.box</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#class-box_1">class: Box</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#module-pypplutilscmd">+ module: pyppl.utils.cmd</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#function-run-cmd-bg-raiseexc-timeout-kwargs">function: run (cmd, bg, raiseExc, timeout, **kwargs)</a></li>
        
            <li><a class="toctree-l3" href="#class-cmd">class: Cmd</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#module-pypplutilsparallel">+ module: pyppl.utils.parallel</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#function-run-func-args-nthread-backend-raiseexc">function: run (func, args, nthread, backend, raiseExc)</a></li>
        
            <li><a class="toctree-l3" href="#class-parallel">class: Parallel</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#module-pypplutilsps">+ module: pyppl.utils.ps</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#function-exists-pid">function: exists (pid)</a></li>
        
            <li><a class="toctree-l3" href="#class-cmd_1">class: Cmd</a></li>
        
            <li><a class="toctree-l3" href="#function-child-pid-pidlist">function: child (pid, pidlist)</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#module-pypplutilssafefs">+ module: pyppl.utils.safefs</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#function-copyfile-src-dst">function: copyfile (src, dst)</a></li>
        
            <li><a class="toctree-l3" href="#function-exists-filepath-callback">function: exists (filepath, callback)</a></li>
        
            <li><a class="toctree-l3" href="#function-move-file1-file2-overwrite-callback">function: move (file1, file2, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#function-gz-file1-file2-overwrite-callback">function: gz (file1, file2, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#function-walk-top-topdown-onerror-followlinks">function: walk (top, topdown, onerror, followlinks)</a></li>
        
            <li><a class="toctree-l3" href="#class-safefs">class: SafeFs</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#file-types">file types</a></li>
    

    <li class="toctree-l2"><a href="#relation-of-two-files">relation of two files</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#method-__init__-self-file1-file2-tmpdir">method: __init__ (self, file1, file2, tmpdir)</a></li>
        
            <li><a class="toctree-l3" href="#method-__repr___5">method: __repr__ ()</a></li>
        
            <li><a class="toctree-l3" href="#method-__setattr___5">method: __setattr__ ()</a></li>
        
            <li><a class="toctree-l3" href="#method-__str___10">method: __str__ ()</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_copy-file1-file2-overwrite-filetype1-filetype2">staticmethod: _copy (file1, file2, overwrite, filetype1, filetype2)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_dirmtime-filepath">staticmethod: _dirmtime (filepath)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_exists-filepath-filetype">staticmethod: _exists (filepath, filetype)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_filerel-file1-file2-filetype1-filetype2">staticmethod: _filerel (file1, file2, filetype1, filetype2)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_filetype-filepath">staticmethod: _filetype (filepath)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_gz-file1-file2-overwrite-filetype1-filetype2">staticmethod: _gz (file1, file2, overwrite, filetype1, filetype2)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_link-file1-file2-overwrite-filetype1-filetype2">staticmethod: _link (file1, file2, overwrite, filetype1, filetype2)</a></li>
        
            <li><a class="toctree-l3" href="#method-_lock-self-lock1-lock2">method: _lock (self, lock1, lock2)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_lockfile-filepath-real-filetype-tmpdir">staticmethod: _lockfile (filepath, real, filetype, tmpdir)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_move-file1-file2-overwrite-filetype1-filetype2">staticmethod: _move (file1, file2, overwrite, filetype1, filetype2)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_remove-filepath-filetype">staticmethod: _remove (filepath, filetype)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-_ungz-file1-file2-overwrite-filetype1-filetype2">staticmethod: _ungz (file1, file2, overwrite, filetype1, filetype2)</a></li>
        
            <li><a class="toctree-l3" href="#method-_unlock-self">method: _unlock (self)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-basename-filepath">staticmethod: basename (filepath)</a></li>
        
            <li><a class="toctree-l3" href="#method-chmodx-self">method: chmodX (self)</a></li>
        
            <li><a class="toctree-l3" href="#method-copy-self-overwrite-callback">method: copy (self, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#method-exists-self-callback">method: exists (self, callback)</a></li>
        
            <li><a class="toctree-l3" href="#method-filesig-self-dirsig">method: filesig (self, dirsig)</a></li>
        
            <li><a class="toctree-l3" href="#staticmethod-flush-fd-lastmsg-end">staticmethod: flush (fd, lastmsg, end)</a></li>
        
            <li><a class="toctree-l3" href="#method-gz-self-overwrite-callback">method: gz (self, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#method-link-self-overwrite-callback">method: link (self, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#method-move-self-overwrite-callback">method: move (self, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#method-movewithlink-self-overwrite-callback">method: moveWithLink (self, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#method-remove-self-callback">method: remove (self, callback)</a></li>
        
            <li><a class="toctree-l3" href="#method-samefile-self-callback">method: samefile (self, callback)</a></li>
        
            <li><a class="toctree-l3" href="#method-ungz-self-overwrite-callback">method: ungz (self, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#function-copytree-src-dst-symlinks-ignore">function: copytree (src, dst, symlinks, ignore)</a></li>
        
            <li><a class="toctree-l3" href="#function-copyfileobj-fsrc-fdst-length">function: copyfileobj (fsrc, fdst, length)</a></li>
        
            <li><a class="toctree-l3" href="#class-chmoderror">class: ChmodError</a></li>
        
            <li><a class="toctree-l3" href="#function-ungz-file1-file2-overwrite-callback">function: ungz (file1, file2, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#function-shmove-src-dst">function: shmove (src, dst)</a></li>
        
            <li><a class="toctree-l3" href="#function-movewithlink-file1-file2-overwrite-callback">function: moveWithLink (file1, file2, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#function-link-file1-file2-overwrite-callback">function: link (file1, file2, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#function-copy-file1-file2-overwrite-callback">function: copy (file1, file2, overwrite, callback)</a></li>
        
            <li><a class="toctree-l3" href="#function-lock">function: Lock ()</a></li>
        
            <li><a class="toctree-l3" href="#function-remove-filepath-callback">function: remove (filepath, callback)</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../faq/">FAQ</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../change-log/">Change log</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">PyPPL</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>API</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="module-pyppl">+ module: pyppl</h2>
<h3 id="class-pyppl">class: <code>PyPPL</code></h3>
<p>The PyPPL class  </p>
<ul>
<li><strong>static variables:</strong><br />
<code>TIPS</code>: The tips for users<br />
<code>RUNNERS</code>: Registered runners<br />
<code>DEFAULT_CFGFILES</code>: Default configuration file  </li>
</ul>
<h4 id="method-__init__-self-config-cfgfile">method: <code>__init__ (self, config, cfgfile)</code></h4>
<p>Constructor  </p>
<ul>
<li><strong>params:</strong><br />
<code>config</code>: the configurations for the pipeline, default: {}<br />
<code>cfgfile</code>:  the configuration file for the pipeline, default: <code>~/.PyPPL.json</code> or <code>./.PyPPL</code>  </li>
</ul>
<h4 id="method-__repr__">method: <code>__repr__ ()</code></h4>
<p>x.<strong>repr</strong>() &lt;==&gt; repr(x)  </p>
<h4 id="method-__setattr__">method: <code>__setattr__ ()</code></h4>
<p>x.<strong>setattr</strong>('name', value) &lt;==&gt; x.name = value  </p>
<h4 id="method-__str__">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h4 id="staticmethod-_any2procs-args">staticmethod: <code>_any2procs (*args)</code></h4>
<p>Get procs from anything (aggr.starts, proc, procs, proc names)  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>arg</code>: anything  </p>
</li>
<li>
<p><strong>returns:</strong><br />
A set of procs  </p>
</li>
</ul>
<h4 id="staticmethod-_checkproc-proc">staticmethod: <code>_checkProc (proc)</code></h4>
<p>Check processes, whether 2 processes have the same id and tag  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>proc</code>: The process  </p>
</li>
<li>
<p><strong>returns:</strong><br />
If there are 2 processes with the same id and tag, raise <code>ValueError</code>.  </p>
</li>
</ul>
<h4 id="staticmethod-_registerproc-proc">staticmethod: <code>_registerProc (proc)</code></h4>
<p>Register the process  </p>
<ul>
<li><strong>params:</strong><br />
<code>proc</code>: The process  </li>
</ul>
<h4 id="method-_resume-self-args-kwargs">method: <code>_resume (self, *args, **kwargs)</code></h4>
<p>Mark processes as to be resumed  </p>
<ul>
<li><strong>params:</strong><br />
<code>args</code>: the processes to be marked. The last element is the mark for processes to be skipped.  </li>
</ul>
<h4 id="method-flowchart-self-fcfile-dotfile">method: <code>flowchart (self, fcfile, dotfile)</code></h4>
<p>Generate graph in dot language and visualize it.  </p>
<ul>
<li><strong>params:</strong><br />
<code>dotfile</code>: Where to same the dot graph. Default: <code>None</code> (<code>path.splitext(sys.argv[0])[0] + ".pyppl.dot"</code>)<br />
<code>fcfile</code>:  The flowchart file. Default: <code>None</code> (<code>path.splitext(sys.argv[0])[0] + ".pyppl.svg"</code>)  </li>
<li>
<p>For example: run <code>python pipeline.py</code> will save it to <code>pipeline.pyppl.svg</code><br />
<code>dot</code>:     The dot visulizer. Default: "dot -Tsvg {{dotfile}} &gt; {{fcfile}}"  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The pipeline object itself.  </p>
</li>
</ul>
<h4 id="staticmethod-registerrunner-runner">staticmethod: <code>registerRunner (runner)</code></h4>
<p>Register a runner  </p>
<ul>
<li><strong>params:</strong><br />
<code>runner</code>: The runner to be registered.  </li>
</ul>
<h4 id="method-resume-self-args">method: <code>resume (self, *args)</code></h4>
<p>Mark processes as to be resumed  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>args</code>: the processes to be marked  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The pipeline object itself.  </p>
</li>
</ul>
<h4 id="method-resume2-self-args">method: <code>resume2 (self, *args)</code></h4>
<p>Mark processes as to be resumed  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>args</code>: the processes to be marked  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The pipeline object itself.  </p>
</li>
</ul>
<h4 id="method-run-self-profile">method: <code>run (self, profile)</code></h4>
<p>Run the pipeline  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>profile</code>: the profile used to run, if not found, it'll be used as runner name. default: 'default'  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The pipeline object itself.  </p>
</li>
</ul>
<h4 id="method-showallroutes-self">method: <code>showAllRoutes (self)</code></h4>
<h4 id="method-start-self-args">method: <code>start (self, *args)</code></h4>
<p>Set the starting processes of the pipeline  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>args</code>: the starting processes  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The pipeline object itself.  </p>
</li>
</ul>
<h3 id="class-proc">class: <code>Proc</code></h3>
<p>The Proc class defining a process  </p>
<ul>
<li>
<p><strong>static variables:</strong><br />
<code>RUNNERS</code>:       The regiested runners<br />
<code>ALIAS</code>:         The alias for the properties<br />
<code>LOG_NLINE</code>:     The limit of lines of logging information of same type of messages  </p>
</li>
<li>
<p><strong>magic methods:</strong><br />
<code>__getattr__(self, name)</code>: get the value of a property in <code>self.props</code><br />
<code>__setattr__(self, name, value)</code>: set the value of a property in <code>self.config</code>  </p>
</li>
</ul>
<h4 id="method-__getattr__-self-name">method: <code>__getattr__ (self, name)</code></h4>
<h4 id="method-__init__-self-tag-desc-id-kwargs">method: <code>__init__ (self, tag, desc, id, **kwargs)</code></h4>
<p>Constructor  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>tag</code>:  The tag of the process<br />
<code>desc</code>: The description of the process<br />
<code>id</code>:   The identify of the process  </p>
</li>
<li>
<p><strong>config:</strong><br />
id, input, output, ppldir, forks, cache, cclean, rc, echo, runner, script, depends, tag, desc, dirsig<br />
exdir, exhow, exow, errhow, errntry, lang, beforeCmd, afterCmd, workdir, args, aggr<br />
callfront, callback, expect, expart, template, tplenvs, resume, nthread  </p>
</li>
<li>
<p><strong>props</strong><br />
input, output, rc, echo, script, depends, beforeCmd, afterCmd, workdir, expect<br />
expart, template, channel, jobs, ncjobids, size, sets, procvars, suffix, logs  </p>
</li>
</ul>
<h4 id="method-__repr__-self">method: <code>__repr__ (self)</code></h4>
<h4 id="method-__setattr__-self-name-value">method: <code>__setattr__ (self, name, value)</code></h4>
<h4 id="method-__str___1">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h4 id="method-_buildinput-self">method: <code>_buildInput (self)</code></h4>
<p>Build the input data<br />
Input could be:<br />
1. list: ['input', 'infile:file'] &lt;=&gt; ['input:var', 'infile:path']<br />
2. str : "input, infile:file" &lt;=&gt; input:var, infile:path<br />
3. dict: {"input": channel1, "infile:file": channel2}<br />
or    {"input:var, input:file" : channel3}<br />
for 1,2 channels will be the combined channel from dependents, if there is not dependents, it will be sys.argv[1:]  </p>
<h4 id="method-_buildjobs-self">method: <code>_buildJobs (self)</code></h4>
<p>Build the jobs.  </p>
<h4 id="method-_buildoutput-self">method: <code>_buildOutput (self)</code></h4>
<p>Build the output data templates waiting to be rendered.  </p>
<h4 id="method-_buildprocvars-self">method: <code>_buildProcVars (self)</code></h4>
<p>Build proc attribute values for template rendering,<br />
and also echo some out.  </p>
<h4 id="method-_buildprops-self">method: <code>_buildProps (self)</code></h4>
<p>Compute some properties  </p>
<h4 id="method-_buildscript-self">method: <code>_buildScript (self)</code></h4>
<p>Build the script template waiting to be rendered.  </p>
<h4 id="method-_checkcached-self">method: <code>_checkCached (self)</code></h4>
<p>Tell whether the jobs are cached  </p>
<ul>
<li><strong>returns:</strong><br />
True if all jobs are cached, otherwise False  </li>
</ul>
<h4 id="method-_readconfig-self-profile-profiles">method: <code>_readConfig (self, profile, profiles)</code></h4>
<p>Read the configuration  </p>
<ul>
<li><strong>params:</strong><br />
<code>config</code>: The configuration  </li>
</ul>
<h4 id="method-_runcmd-self-key">method: <code>_runCmd (self, key)</code></h4>
<p>Run the <code>beforeCmd</code> or <code>afterCmd</code>  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>key</code>: "beforeCmd" or "afterCmd"  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The return code of the command  </p>
</li>
</ul>
<h4 id="method-_runjobs-self">method: <code>_runJobs (self)</code></h4>
<p>Submit and run the jobs  </p>
<h4 id="method-_savesettings-self">method: <code>_saveSettings (self)</code></h4>
<p>Save all settings in proc.settings, mostly for debug  </p>
<h4 id="method-_suffix-self">method: <code>_suffix (self)</code></h4>
<p>Calcuate a uid for the process according to the configuration<br />
The philosophy:<br />
1. procs from different script must have different suffix (sys.argv[0])<br />
2. procs from the same script:<br />
- procs with different id or tag have different suffix<br />
- procs with different input have different suffix (depends, input)  </p>
<ul>
<li><strong>returns:</strong><br />
The uniq id of the process  </li>
</ul>
<h4 id="method-_tidyafterrun-self">method: <code>_tidyAfterRun (self)</code></h4>
<p>Do some cleaning after running jobs<br />
self.resume can only be:<br />
- '': normal process<br />
- skip+: skipped process but required workdir and data exists<br />
- resume: resume pipeline from this process, no requirement<br />
- resume+: get data from workdir/proc.settings, and resume  </p>
<h4 id="method-_tidybeforerun-self">method: <code>_tidyBeforeRun (self)</code></h4>
<p>Do some preparation before running jobs  </p>
<h4 id="method-copy-self-tag-desc-id">method: <code>copy (self, tag, desc, id)</code></h4>
<p>Copy a process  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>id</code>: The new id of the process, default: <code>None</code> (use the varname)<br />
<code>tag</code>:   The tag of the new process, default: <code>None</code> (used the old one)<br />
<code>desc</code>:  The desc of the new process, default: <code>None</code> (used the old one)  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The new process  </p>
</li>
</ul>
<h4 id="method-log-self-msg-level-key">method: <code>log (self, msg, level, key)</code></h4>
<p>The log function with aggregation name, process id and tag integrated.  </p>
<ul>
<li><strong>params:</strong><br />
<code>msg</code>:   The message to log<br />
<code>level</code>: The log level<br />
<code>key</code>:   The type of messages  </li>
</ul>
<h4 id="method-name-self-aggr">method: <code>name (self, aggr)</code></h4>
<p>Get my name include <code>aggr</code>, <code>id</code>, <code>tag</code>  </p>
<ul>
<li><strong>returns:</strong><br />
the name  </li>
</ul>
<h4 id="method-run-self-profile-profiles">method: <code>run (self, profile, profiles)</code></h4>
<p>Run the jobs with a configuration  </p>
<ul>
<li><strong>params:</strong><br />
<code>config</code>: The configuration  </li>
</ul>
<h2 id="module-pypplaggr">+ module: pyppl.aggr</h2>
<p>The aggregation of procs  </p>
<h3 id="class-_proxy">class: <code>_Proxy</code></h3>
<p>A proxy for a list of procs to set/get their attributes  </p>
<h4 id="method-__getattr__-self-name_1">method: <code>__getattr__ (self, name)</code></h4>
<h4 id="method-__getitem__-self-name">method: <code>__getitem__ (self, name)</code></h4>
<h4 id="method-__init__-self-aggr-procs-prefix-check">method: <code>__init__ (self, aggr, procs, prefix, check)</code></h4>
<h4 id="method-__repr___1">method: <code>__repr__ ()</code></h4>
<p>x.<strong>repr</strong>() &lt;==&gt; repr(x)  </p>
<h4 id="method-__setattr__-self-name-value_1">method: <code>__setattr__ (self, name, value)</code></h4>
<h4 id="method-__setitem__-self-name-value">method: <code>__setitem__ (self, name, value)</code></h4>
<h4 id="method-__str___2">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h3 id="class-aggrattributeerror">class: <code>AggrAttributeError</code></h3>
<p>Raise when there is an error to set/get Aggr attributes  </p>
<h4 id="method-__getitem__">method: <code>__getitem__ ()</code></h4>
<p>x.<strong>getitem</strong>(y) &lt;==&gt; x[y]  </p>
<h4 id="method-__init__-self-key-msg">method: <code>__init__ (self, key, msg)</code></h4>
<h4 id="method-__repr___2">method: <code>__repr__ ()</code></h4>
<p>x.<strong>repr</strong>() &lt;==&gt; repr(x)  </p>
<h4 id="method-__setattr___1">method: <code>__setattr__ ()</code></h4>
<p>x.<strong>setattr</strong>('name', value) &lt;==&gt; x.name = value  </p>
<h4 id="method-__str___3">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h3 id="class-aggr">class: <code>Aggr</code></h3>
<p>The aggregation of a set of processes  </p>
<ul>
<li><strong>magic methods:</strong><br />
<code>__setattr__(self, name, value)</code>: Set property value of an aggregation.  </li>
<li>if it's a common property, set it to all processes  </li>
<li>if it is <code>input</code> set it to starting processes  </li>
<li>if it is <code>depends</code> set it to the end processes  </li>
<li>if it is related to <code>export</code> (startswith <code>ex</code>), set it to the end processes  </li>
<li>if it is in ['starts', 'ends', 'id'], set it to the aggregation itself.  </li>
<li>Otherwise a <code>ValueError</code> raised.  </li>
<li>You can use <code>[aggr].[proc].[prop]</code> to set/get the properties of a processes in the aggregation.  </li>
</ul>
<h4 id="method-__getattr__-self-name_2">method: <code>__getattr__ (self, name)</code></h4>
<h4 id="method-__getitem__-self-key">method: <code>__getitem__ (self, key)</code></h4>
<p>Select processes<br />
<div class="highlight"><pre><span></span># self._procs = OrderedDict([  
#	(&#39;a&#39;, Proc(id = &#39;a&#39;)),  
#	(&#39;b&#39;, Proc(id = &#39;b&#39;)),  
#	(&#39;c&#39;, Proc(id = &#39;c&#39;)),  
#	(&#39;d&#39;, Proc(id = &#39;d&#39;))  
# ])  
  
self[&#39;a&#39;] # proc a  
self[0]   # proc a  
self[1:2] # _Proxy of (proc b, proc c)  
self[1,3] # _Proxy of (proc b, proc d)  
self[&#39;b&#39;, &#39;c&#39;] # _Proxy of (proc b, proc c)  
self[&#39;b,c&#39;] # _Proxy of (proc b, proc c)  
self[Proc(id = &#39;d&#39;)] # proc d  
</pre></div></p>
<h4 id="method-__init__-self-args-kwargs">method: <code>__init__ (self, *args, **kwargs)</code></h4>
<p>Constructor  </p>
<ul>
<li><strong>params:</strong><br />
<code>args</code>: the set of processes<br />
<code>depends</code>: Whether auto deduce depends. Default: True<br />
<code>id</code>: The id of the aggr. Default: None (the variable name)<br />
<code>tag</code>: The tag of the processes. Default: None (a unique 4-char str according to the id)  </li>
</ul>
<h4 id="method-__repr___3">method: <code>__repr__ ()</code></h4>
<p>x.<strong>repr</strong>() &lt;==&gt; repr(x)  </p>
<h4 id="method-__setattr__-self-name-value_2">method: <code>__setattr__ (self, name, value)</code></h4>
<h4 id="method-__str___4">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h4 id="method-_select-self-key-forcelist-flatten">method: <code>_select (self, key, forceList, flatten)</code></h4>
<p>Select processes<br />
<div class="highlight"><pre><span></span># self._procs = OrderedDict([  
#	(&#39;a&#39;, Proc(id = &#39;a&#39;)),  
#	(&#39;b&#39;, Proc(id = &#39;b&#39;)),  
#	(&#39;c&#39;, Proc(id = &#39;c&#39;)),  
#	(&#39;d&#39;, Proc(id = &#39;d&#39;))  
# ])  
  
self[&#39;a&#39;] # proc a  
self[0]   # proc a  
self[1:2] # _Proxy of (proc b, proc c)  
self[1,3] # _Proxy of (proc b, proc d)  
self[&#39;b&#39;, &#39;c&#39;] # _Proxy of (proc b, proc c)  
self[&#39;b,c&#39;] # _Proxy of (proc b, proc c)  
self[Proc(id = &#39;d&#39;)] # proc d  
  
### method: `addEnd (self, *procs)`
  
Add end processes  

- **params:**  
`procs`: The selector of processes to add  
  
### method: `addProc (self, p, tag, where, copy)`
  
Add a process to the aggregation.  
Note that you have to adjust the dependencies after you add processes.  

- **params:**  
`p`:     The process  
`where`: Add to where: &#39;starts&#39;, &#39;ends&#39;, &#39;both&#39; or None (default)  

- **returns:**  
the aggregation itself  
  
### method: `addStart (self, *procs)`
  
Add start processes  

- **params:**  
`procs`: The selector of processes to add  
  
### method: `copy (self, tag, depends, id, delegates, modules)`
  
Like `proc`&#39;s `copy` function, copy an aggregation. Each processes will be copied.  

- **params:**  
`tag`:      The new tag of all copied processes  
`depends`: Whether to copy the dependencies or not. Default: True  
- dependences for processes in starts will not be copied  
`id`:    Use a different id if you don&#39;t want to use the variant name  
`delegates`: Copy delegates? Default: `True`  
`configs`: Copy configs? Default: `True`  

- **returns:**  
The new aggregation  
  
### method: `delEnd (self, *procs)`
  
Delete end processes  

- **params:**  
`procs`: The selector of processes to delete  
  
### method: `delStart (self, *procs)`
  
Delete start processes  

- **params:**  
`procs`: The selector of processes to delete  
  
### method: `delegate (self, attrs, procs)`
  
Delegate the procs to have the attributes set by:  
`aggr.args.a.b = 1`  
Instead of setting `args.a.b` of all processes, `args.a.b` of only delegated processes will be set.  
`procs` can be `starts`/`ends`, but it cannot be set with other procs, which means you can do:  
`aggr.delegate(&#39;args&#39;, &#39;starts&#39;)`, but not `aggr.delegate(&#39;args&#39;, [&#39;starts&#39;, &#39;pXXX&#39;])`  
  
### method: `module (self, name, starts, depends, ends, starts_shared, depends_shared, ends_shared)`
  
Define a function for aggr.  
The &quot;shared&quot; parameters will be indicators not to remove those processes  
when the shared function is on.  

- **params:**  
`name`          : The name of the function  
`starts`        : A list of start processes.  
`depends`       : A dict of dependences of the procs  
`ends`          : A list of end processes  
`starts_shared` : A dict of functions that shares the same starts  
`depends_shared`: A dict of functions that shares the same depends  
`ends_shared`   : A dict of functions that shares the same ends  
- For example: `{&lt;procs&gt;: &lt;func&gt;}`  
  
### method: `moduleFunc (self, name, on, off)`
  
Define modules using functions  

- **params:**  
`name`: The name of the module  
`on`  : The function when the module is turned on  
`off` : The function when the module is turned off  
  
### method: `off (self, *names)`
  
Turn off modules  

- **params:**  
`names`: The names of the modules.  
  
### method: `on (self, *names)`
  
Turn on modules  

- **params:**  
`names`: The names of the modules.  
  
##   class: `AggrKeyError`
  
Raise when error occurred doing aggr[...]  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, key, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `AggrCopyError`
  
Raise when there is an error to set/get Aggr attributes  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, key, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
# + module: pyppl.channel
  
Channel for pyppl  
  
##   function: `glob (pathname)`
Return a list of paths matching a pathname pattern.  
  
The pattern may contain simple shell-style wildcards a la  
fnmatch. However, unlike fnmatch, filenames starting with a  
dot are special cases that are not matched by &#39;*&#39; and &#39;?&#39;  
patterns.  
  
  
##   class: `Channel`
  
The channen class, extended from `list`  
  
### method: `__add__ ()`
x.__add__(y) &lt;==&gt; x+y  
### method: `__contains__ ()`
x.__contains__(y) &lt;==&gt; y in x  
### method: `__delitem__ ()`
x.__delitem__(y) &lt;==&gt; del x[y]  
### method: `__delslice__ ()`
x.__delslice__(i, j) &lt;==&gt; del x[i:j]  
  
Use of negative indices is not supported.  
### method: `__ge__ ()`
x.__ge__(y) &lt;==&gt; x&gt;=y  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__gt__ ()`
x.__gt__(y) &lt;==&gt; x&gt;y  
### method: `__iadd__ ()`
x.__iadd__(y) &lt;==&gt; x+=y  
### method: `__imul__ ()`
x.__imul__(y) &lt;==&gt; x*=y  
### method: `__init__ ()`
x.__init__(...) initializes x; see help(type(x)) for signature  
### method: `__iter__ ()`
x.__iter__() &lt;==&gt; iter(x)  
### method: `__le__ ()`
x.__le__(y) &lt;==&gt; x&lt;=y  
### method: `__len__ ()`
x.__len__() &lt;==&gt; len(x)  
### method: `__lt__ ()`
x.__lt__(y) &lt;==&gt; x&lt;y  
### method: `__mul__ ()`
x.__mul__(n) &lt;==&gt; x*n  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__reversed__ ()`
L.__reversed__() -- return a reverse iterator over the list  
### method: `__rmul__ ()`
x.__rmul__(n) &lt;==&gt; n*x  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__setitem__ ()`
x.__setitem__(i, y) &lt;==&gt; x[i]=y  
### method: `__setslice__ ()`
x.__setslice__(i, j, y) &lt;==&gt; x[i:j]=y  
  
Use  of negative indices is not supported.  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### staticmethod: `_tuplize (tu)`
  
A private method, try to convert an element to tuple  
If it&#39;s a string, convert it to `(tu, )`  
Else if it is iterable, convert it to `tuple(tu)`  
Otherwise, convert it to `(tu, )`  
Notice that string is also iterable.  

- **params:**  
`tu`: the element to be converted  

- **returns:**  
The converted element  
  
### method: `append ()`
L.append(object) -- append object to end  
### method: `attach (self, *names, **kwargs)`
  
Attach columns to names of Channel, so we can access each column by:  
`ch.col0` == ch.colAt(0)  

- **params:**  
`names`: The names. Have to be as length as channel&#39;s width. None of them should be Channel&#39;s property name  
`flatten`: Whether flatten the channel for the name being attached  
  
### method: `cbind (self, *cols)`
  
Add columns to the channel  

- **params:**  
`cols`: The columns  

- **returns:**  
The channel with the columns inserted.  
  
### method: `colAt (self, index)`
  
Fetch one column of a Channel  

- **params:**  
`index`: which column to fetch  

- **returns:**  
The Channel with that column  
  
### method: `collapse (self, col)`
  
Do the reverse of expand  
length: N -&gt; 1  
width:  M -&gt; M  

- **params:**  
`col`:     the index of the column used to collapse  

- **returns:**  
The collapsed Channel  
  
### method: `copy (self)`
  
Copy a Channel using `copy.copy`  

- **returns:**  
The copied Channel  
  
### method: `count ()`
L.count(value) -&gt; integer -- return number of occurrences of value  
### staticmethod: `create (l)`
  
Create a Channel from a list  

- **params:**  
`l`: The list, default: []  

- **returns:**  
The Channel created from the list  
  
### method: `expand (self, col, pattern, t, sortby, reverse)`
  
expand the Channel according to the files in &lt;col&gt;, other cols will keep the same  
`[(dir1/dir2, 1)].expand (0, &quot;*&quot;)` will expand to  
`[(dir1/dir2/file1, 1), (dir1/dir2/file2, 1), ...]`  
length: 1 -&gt; N  
width:  M -&gt; M  

- **params:**  
`col`:     the index of the column used to expand  
`pattern`: use a pattern to filter the files/dirs, default: `*`  
`t`:       the type of the files/dirs to include  
- &#39;dir&#39;, &#39;file&#39;, &#39;link&#39; or &#39;any&#39; (default)  
`sortby`:  how the list is sorted  
- &#39;name&#39; (default), &#39;mtime&#39;, &#39;size&#39;  
`reverse`: reverse sort. Default: False  

- **returns:**  
The expanded Channel  
  
### method: `extend ()`
L.extend(iterable) -- extend list by appending elements from the iterable  
### method: `filter (self, func)`
  
Alias of python builtin `filter`  

- **params:**  
`func`: the function. Default: None  

- **returns:**  
The filtered Channel  
  
### method: `filterCol (self, func, col)`
  
Just filter on the first column  

- **params:**  
`func`: the function  
`col`: the column to filter  

- **returns:**  
The filtered Channel  
  
### method: `flatten (self, col)`
  
Convert a single-column Channel to a list (remove the tuple signs)  
`[(a,), (b,)]` to `[a, b]`  

- **params:**  
`col`: The column to flat. None for all columns (default)  

- **returns:**  
The list converted from the Channel.  
  
### method: `fold (self, n)`
  
Fold a Channel. Make a row to n-length chunk rows  
</pre></div>
a1  a2  a3  a4<br />
b1  b2  b3  b4<br />
if n==2, fold(2) will change it to:<br />
a1  a2<br />
a3  a4<br />
b1  b2<br />
b3  b4<br />
<div class="highlight"><pre><span></span>- **params:**  
`n`: the size of the chunk  

- **returns**  
The new Channel  
  
### staticmethod: `fromArgv ()`
  
Create a Channel from `sys.argv[1:]`  
&quot;python test.py a b c&quot; creates a width=1 Channel  
&quot;python test.py a,1 b,2 c,3&quot; creates a width=2 Channel  

- **returns:**  
The Channel created from the command line arguments  
  
### staticmethod: `fromChannels (*args)`
  
Create a Channel from Channels  

- **params:**  
`args`: The Channels  

- **returns:**  
The Channel merged from other Channels  
  
### staticmethod: `fromFile (fn, header, skip, delimit)`
  
Create Channel from the file content  
It&#39;s like a matrix file, each row is a row for a Channel.  
And each column is a column for a Channel.  

- **params:**  
`fn`:      the file  
`header`:  Whether the file contains header. If True, will attach the header  
- So you can use `channel.&lt;header&gt;` to fetch the column  
`skip`:    first lines to skip  
`delimit`: the delimit for columns  

- **returns:**  
A Channel created from the file  
  
### staticmethod: `fromPairs (pattern)`
  
Create a width = 2 Channel from a pattern  

- **params:**  
`pattern`: the pattern  

- **returns:**  
The Channel create from every 2 files match the pattern  
  
### staticmethod: `fromParams (*pnames)`
  
Create a Channel from params  

- **params:**  
`*pnames`: The names of the option  

- **returns:**  
The Channel  
  
### staticmethod: `fromPattern (pattern, t, sortby, reverse)`
  
Create a Channel from a path pattern  

- **params:**  
`pattern`: the pattern with wild cards  
`t`:       the type of the files/dirs to include  
- &#39;dir&#39;, &#39;file&#39;, &#39;link&#39; or &#39;any&#39; (default)  
`sortby`:  how the list is sorted  
- &#39;name&#39; (default), &#39;mtime&#39;, &#39;size&#39;  
`reverse`: reverse sort. Default: False  

- **returns:**  
The Channel created from the path  
  
### method: `get (self, idx)`
  
Get the element of a flattened channel  

- **params:**  
`idx`: The index of the element to get. Default: 0  

- **return:**  
The element  
  
### method: `index ()`
L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.  
Raises ValueError if the value is not present.  
### method: `insert (self, cidx, *cols)`
  
Insert columns to a channel  

- **params:**  
`cidx`: Insert into which index of column?  
`cols`: the columns to be bound to Channel  

- **returns:**  
The combined Channel  
Note, self is also changed  
  
### method: `length (self)`
  
Get the length of a Channel  
It&#39;s just an alias of `len(chan)`  

- **returns:**  
The length of the Channel  
  
### method: `map (self, func)`
  
Alias of python builtin `map`  

- **params:**  
`func`: the function  

- **returns:**  
The transformed Channel  
  
### method: `mapCol (self, func, col)`
  
Map for a column  

- **params:**  
`func`: the function  
`col`: the index of the column. Default: 0  

- **returns:**  
The transformed Channel  
  
### staticmethod: `nones (length, width)`
  
Create a channel with `None`s  

- **params:**  
`length`: The length of the channel  
`width`:  The width of the channel  

- **returns:**  
The created channel  
  
### method: `pop ()`
L.pop([index]) -&gt; item -- remove and return item at index (default last).  
Raises IndexError if list is empty or index is out of range.  
### method: `rbind (self, *rows)`
  
The multiple-argument versoin of `rbind`  

- **params:**  
`rows`: the rows to be bound to Channel  

- **returns:**  
The combined Channel  
Note, self is also changed  
  
### method: `reduce (self, func)`
  
Alias of python builtin `reduce`  

- **params:**  
`func`: the function  

- **returns:**  
The reduced value  
  
### method: `reduceCol (self, func, col)`
  
Reduce a column  

- **params:**  
`func`: the function  
`col`: the column to reduce  

- **returns:**  
The reduced value  
  
### method: `remove ()`
L.remove(value) -- remove first occurrence of value.  
Raises ValueError if the value is not present.  
### method: `repCol (self, n)`
  
Repeat column and return a new channel  

- **params:**  
`n`: how many times to repeat.  

- **returns:**  
The new channel with repeated columns  
  
### method: `repRow (self, n)`
  
Repeat row and return a new channel  

- **params:**  
`n`: how many times to repeat.  

- **returns:**  
The new channel with repeated rows  
  
### method: `reverse ()`
L.reverse() -- reverse *IN PLACE*  
### method: `rowAt (self, index)`
  
Fetch one row of a Channel  

- **params:**  
`index`: which row to fetch  

- **returns:**  
The Channel with that row  
  
### method: `slice (self, start, length)`
  
Fetch some columns of a Channel  

- **params:**  
`start`:  from column to start  
`length`: how many columns to fetch, default: None (from start to the end)  

- **returns:**  
The Channel with fetched columns  
  
### method: `sort ()`
L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;  
cmp(x, y) -&gt; -1, 0, 1  
### method: `split (self, flatten)`
  
Split a Channel to single-column Channels  

- **returns:**  
The list of single-column Channels  
  
### method: `t (self)`
  
Transpose the channel  

- **returns:**  
The transposed channel.  
  
### method: `transpose (self)`
  
Transpose the channel  

- **returns:**  
The transposed channel.  
  
### method: `unfold (self, n)`
  
Do the reverse thing as self.fold does  

- **params:**  
`n`: How many rows to combind each time. default: 2  

- **returns:**  
The unfolded Channel  
  
### method: `unique (self)`
  
Make the channel unique, remove duplicated rows  
Try to keep the order  
  
### method: `width (self)`
  
Get the width of a Channel  

- **returns:**  
The width of the Channel  
  
# + module: pyppl.exception
  
A set of exceptions used by PyPPL  
  
##   class: `PyPPLProcFindError`
  
Raise when failed to find a proc  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, p, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `PyPPLProcRelationError`
  
Raise when failed to parse the relation of processes  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, p, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `TemplatePyPPLSyntaxError`
  
Raised when a template has a syntax error.  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, src, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ProcAttributeError`
  
Raise when set/get process&#39; attributes  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `TemplatePyPPLRenderError`
  
Failed to render a template  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, stack, src)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ProcInputError`
  
Raise when failed to parse process input  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `LoggerThemeError`
  
Theme errors for logger  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `JobInputParseError`
  
Raise when failed to parse the input data for jobs  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ParameterNameError`
  
Malformed name not allowed  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `JobOutputParseError`
  
Raise when failed to parse the output data for jobs  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ProcRunCmdError`
  
Raise when failed to run before/after cmds for process  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, cmd, key, ex)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ProcTreeParseError`
  
Raise when failed to parse the tree  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `AggrKeyError`
  
Raise when error occurred doing aggr[...]  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, key, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `AggrCopyError`
  
Raise when there is an error to set/get Aggr attributes  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, key, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `PyPPLConfigError`
  
Raise when failed to parse the configuration of pyppl  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, key, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ProcTagError`
  
Raise when malformed tag is assigned to a process  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ParametersLoadError`
  
Error loading dict to Parameters  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `AggrAttributeError`
  
Raise when there is an error to set/get Aggr attributes  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, key, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ParameterTypeError`
  
Unable to set type  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `RunnerSshError`
  
Raise when failed to initiate RunnerSsh  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ParametersParseError`
  
Error when parsing the parameters  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ProcOutputError`
  
Raise when failed to parse process output  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ProcTreeProcExists`
  
Raise when two Procs with same id and tag defined  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, pn1, pn2)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ProcScriptError`
  
Raise when failed to parse process script  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
# + module: pyppl.flowchart
  
##   function: `deepcopy (x, memo, _nil)`
Deep copy operation on arbitrary Python objects.  
  
See the module&#39;s __doc__ string for more info.  
  
##   class: `Digraph`
Directed graph source code in the DOT language.  
  
Args:  
name: Graph name used in the source code.  
comment: Comment added to the first line of the source.  
filename: Filename for saving the source (defaults to `name` + &#39;.gv&#39;).  
directory: (Sub)directory for source saving and rendering.  
format: Rendering output format (&#39;pdf&#39;, &#39;png&#39;, ...).  
engine: Layout command used (&#39;dot&#39;, &#39;neato&#39;, ...).  
encoding: Encoding for saving the source.  
graph_attr: Mapping of (attribute, value) pairs for the graph.  
node_attr: Mapping of (attribute, value) pairs set for all nodes.  
edge_attr: Mapping of (attribute, value) pairs set for all edges.  
body: Iterable of verbatim lines to add to the graph body.  
strict(bool): Rendering should merge multi-edges.  
  
.. note::  
All parameters are optional and can be changed under their  
corresponding attribute name after instance creation.  
  
### method: `__init__ (self, name, comment, filename, directory, format, engine, encoding, graph_attr, node_attr, edge_attr, body, strict)`
  
### method: `__iter__ (self, subgraph)`
Yield the DOT source code line by line (as graph or subgraph).  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ (self)`
The DOT source code as string.  
### staticmethod: `_a_list (label, kwargs, attributes)`
Return assembled DOT a_list string.  
  
&gt;&gt;&gt; a_list(&#39;spam&#39;, {&#39;spam&#39;: None, &#39;ham&#39;: &#39;ham ham&#39;, &#39;eggs&#39;: &#39;&#39;})  
&#39;label=spam eggs=&quot;&quot; ham=&quot;ham ham&quot;&#39;  
  
### staticmethod: `_attr_list (label, kwargs, attributes)`
Return assembled DOT attribute list string.  
  
Sorts kwargs and attributes if they are plain dicts (to avoid  
unpredictable order from hash randomization in Python 3.3+).  
  
&gt;&gt;&gt; attr_list()  
&#39;&#39;  
  
&gt;&gt;&gt; attr_list(&#39;spam spam&#39;, kwargs={&#39;eggs&#39;: &#39;eggs&#39;, &#39;ham&#39;: &#39;ham ham&#39;})  
&#39; [label=&quot;spam spam&quot; eggs=eggs ham=&quot;ham ham&quot;]&#39;  
  
&gt;&gt;&gt; attr_list(kwargs={&#39;spam&#39;: None, &#39;eggs&#39;: &#39;&#39;})  
&#39; [eggs=&quot;&quot;]&#39;  
  
### method: `_kwargs (self)`
  
### staticmethod: `_quote (identifier, valid_id, dot_keyword, html)`
Return DOT identifier from string, quote if needed.  
  
&gt;&gt;&gt; quote(&#39;&#39;)  
&#39;&quot;&quot;&#39;  
  
&gt;&gt;&gt; quote(&#39;spam&#39;)  
&#39;spam&#39;  
  
&gt;&gt;&gt; quote(&#39;spam spam&#39;)  
&#39;&quot;spam spam&quot;&#39;  
  
&gt;&gt;&gt; quote(&#39;-4.2&#39;)  
&#39;-4.2&#39;  
  
&gt;&gt;&gt; quote(&#39;.42&#39;)  
&#39;.42&#39;  
  
&gt;&gt;&gt; quote(&#39;&lt;&lt;b&gt;spam&lt;/b&gt;&gt;&#39;)  
&#39;&lt;&lt;b&gt;spam&lt;/b&gt;&gt;&#39;  
  
### staticmethod: `_quote_edge (identifier)`
Return DOT edge statement node_id from string, quote if needed.  
  
&gt;&gt;&gt; quote_edge(&#39;spam&#39;)  
&#39;spam&#39;  
  
&gt;&gt;&gt; quote_edge(&#39;spam spam:eggs eggs&#39;)  
&#39;&quot;spam spam&quot;:&quot;eggs eggs&quot;&#39;  
  
&gt;&gt;&gt; quote_edge(&#39;spam:eggs:s&#39;)  
&#39;spam:eggs:s&#39;  
  
### method: `_repr_svg_ (self)`
  
### method: `_view (self, filepath, format)`
Start the right viewer based on file format and platform.  
### staticmethod: `_view_darwin (filepath)`
Open filepath with its default application (mac).  
### staticmethod: `_view_freebsd (filepath)`
Open filepath in the user&#39;s preferred application (linux, freebsd).  
### staticmethod: `_view_linux (filepath)`
Open filepath in the user&#39;s preferred application (linux, freebsd).  
### staticmethod: `_view_windows (filepath)`
Start filepath with its associated application (windows).  
### method: `attr (self, kw, _attributes, **attrs)`
Add a general or graph/node/edge attribute statement.  
  
Args:  
kw: Attributes target (None or &#39;graph&#39;, &#39;node&#39;, &#39;edge&#39;).  
attrs: Attributes to be set (must be strings, may be empty).  
  
See the :ref:`usage examples in the User Guide &lt;attributes&gt;`.  
  
### method: `clear (self, keep_attrs)`
Reset content to an empty body, clear graph/node/egde_attr mappings.  
  
Args:  
keep_attrs(bool): preserve graph/node/egde_attr mappings  
  
### method: `copy (self)`
Return a copied instance of the object.  
### method: `edge (self, tail_name, head_name, label, _attributes, **attrs)`
Create an edge between two nodes.  
  
Args:  
tail_name: Start node identifier.  
head_name: End node identifier.  
label: Caption to be displayed near the edge.  
attrs: Any additional edge attributes (must be strings).  
  
### method: `edges (self, tail_head_iter)`
Create a bunch of edges.  
  
Args:  
tail_head_iter: Iterable of (tail_name, head_name) pairs.  
  
### method: `node (self, name, label, _attributes, **attrs)`
Create a node.  
  
Args:  
name: Unique identifier for the node inside the source.  
label: Caption to be displayed (defaults to the node name).  
attrs: Any additional node attributes (must be strings).  
  
### method: `pipe (self, format)`
Return the source piped through the Graphviz layout command.  
  
Args:  
format: The output format used for rendering (&#39;pdf&#39;, &#39;png&#39;, etc.).  
Returns:  
Binary (encoded) stdout of the layout command.  
Raises:  
ValueError: If `format` is not known.  
graphviz.ExecutableNotFound: If the Graphviz executable is not found.  
subprocess.CalledProcessError: If the exit status is non-zero.  
  
### method: `render (self, filename, directory, view, cleanup)`
Save the source to file and render with the Graphviz engine.  
  
Args:  
filename: Filename for saving the source (defaults to `name` + &#39;.gv&#39;)  
directory: (Sub)directory for source saving and rendering.  
view(bool): Open the rendered result with the default application.  
cleanup(bool): Delete the source file after rendering.  
Returns:  
The (possibly relative) path of the rendered file.  
Raises:  
graphviz.ExecutableNotFound: If the Graphviz executable is not found.  
subprocess.CalledProcessError: If the exit status is non-zero.  
RuntimeError: If viewer opening is requested but not supported.  
  
### method: `save (self, filename, directory)`
Save the DOT source to file. Ensure the file ends with a newline.  
  
Args:  
filename: Filename for saving the source (defaults to `name` + &#39;.gv&#39;)  
directory: (Sub)directory for source saving and rendering.  
Returns:  
The (possibly relative) path of the saved source file.  
  
### method: `subgraph (self, graph, name, comment, graph_attr, node_attr, edge_attr, body)`
Add the current content of the given sole `graph` argument as subgraph            or return a context manager returning a new graph instance created            with the given (`name`, `comment`, etc.) arguments whose content is            added as subgraph when leaving the context manager&#39;s ``with``-block.  
  
Args:  
graph: An instance of the same kind (:class:`.Graph`, :class:`.Digraph`)  
as the current graph (sole argument in non-with-block use).  
name: Subgraph name (with-block use).  
comment: Subgraph comment (with-block use).  
graph_attr: Subgraph-level attribute-value mapping (with-block use).  
node_attr: Node-level attribute-value mapping (with-block use).  
edge_attr: Edge-level attribute-value mapping (with-block use).  
body: Verbatim lines to add to the subgraph body (with-block use).  
  
See the :ref:`usage examples in the User Guide &lt;subgraphs&gt;`.  
  
.. note::  
If the `name` of the subgraph begins with &#39;cluster&#39; (all lowercase)  
the layout engine will treat it as a special cluster subgraph.  
  
### method: `view (self, filename, directory, cleanup)`
Save the source to file, open the rendered result in a viewer.  
  
Args:  
filename: Filename for saving the source (defaults to name + &#39;.gv&#39;)  
directory: (Sub)directory for source saving and rendering.  
cleanup(bool): Delete the source file after rendering.  
Returns:  
The (possibly relative) path of the rendered file.  
Raises:  
graphviz.ExecutableNotFound: If the Graphviz executable is not found.  
subprocess.CalledProcessError: If the exit status is non-zero.  
RuntimeError: If opening the viewer is not supported.  
  
Short-cut method for calling :meth:`.render` with ``view=True``.  
  
##   class: `Flowchart`
  
Draw flowchart for pipelines  
  

- **static variables:**  
`THEMES`: predefined themes  
  
### method: `__init__ (self, fcfile, dotfile)`
  
The constructor  

- **params:**  
`fcfile`: The flowchart file. Default: `path.splitext(sys.argv[0])[0] + &#39;.pyppl.svg&#39;`  
`dotfile`: The dot file. Default: `path.splitext(sys.argv[0])[0] + &#39;.pyppl.dot&#39;`  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_assemble (self)`
  
Assemble the graph for printing and rendering  
  
### method: `addLink (self, node1, node2)`
  
Add a link to the chart  

- **params:**  
`node1`: The first node.  
`node2`: The second node.  
  
### method: `addNode (self, node, role)`
  
Add a node to the chart  

- **params:**  
`node`: The node  
`role`: Is it a starting node, an ending node or None. Default: None.  
  
### method: `generate (self)`
  
Generate the dot file and graph file.  
  
### method: `setTheme (self, theme, base)`
  
Set the theme to be used  

- **params:**  
`theme`: The theme, could be the key of Flowchart.THEMES or a dict of a theme definition.  
`base` : The base theme to be based on you pass custom theme  
  
# + module: pyppl.job
  
Job module for pyppl  
  
##   class: `JobInputParseError`
  
Raise when failed to parse the input data for jobs  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   function: `Lock ()`
  
Returns a non-recursive lock object  
  
##   function: `glob (pathname)`
Return a list of paths matching a pathname pattern.  
  
The pattern may contain simple shell-style wildcards a la  
fnmatch. However, unlike fnmatch, filenames starting with a  
dot are special cases that are not matched by &#39;*&#39; and &#39;?&#39;  
patterns.  
  
  
##   class: `datetime`
datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])  
  
The year, month and day arguments are required. tzinfo may be None, or an  
instance of a tzinfo subclass. The remaining arguments may be ints or longs.  
  
### method: `__add__ ()`
x.__add__(y) &lt;==&gt; x+y  
### method: `__ge__ ()`
x.__ge__(y) &lt;==&gt; x&gt;=y  
### method: `__gt__ ()`
x.__gt__(y) &lt;==&gt; x&gt;y  
### method: `__init__ ()`
x.__init__(...) initializes x; see help(type(x)) for signature  
### method: `__le__ ()`
x.__le__(y) &lt;==&gt; x&lt;=y  
### method: `__lt__ ()`
x.__lt__(y) &lt;==&gt; x&lt;y  
### method: `__radd__ ()`
x.__radd__(y) &lt;==&gt; y+x  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__rsub__ ()`
x.__rsub__(y) &lt;==&gt; y-x  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `__sub__ ()`
x.__sub__(y) &lt;==&gt; x-y  
### method: `astimezone ()`
tz -&gt; convert to local time in new timezone tz  
  
### method: `combine ()`
date, time -&gt; datetime with same date and time fields  
### method: `ctime ()`
Return ctime() style string.  
### method: `date ()`
Return date object with same year, month and day.  
### method: `dst ()`
Return self.tzinfo.dst(self).  
### method: `fromordinal ()`
int -&gt; date corresponding to a proleptic Gregorian ordinal.  
### method: `fromtimestamp ()`
timestamp[, tz] -&gt; tz&#39;s local time from POSIX timestamp.  
### method: `isocalendar ()`
Return a 3-tuple containing ISO year, week number, and weekday.  
### method: `isoformat ()`
[sep] -&gt; string in ISO 8601 format, YYYY-MM-DDTHH:MM:SS[.mmmmmm][+HH:MM].  
  
sep is used to separate the year from the time, and defaults to &#39;T&#39;.  
### method: `isoweekday ()`
Return the day of the week represented by the date.  
Monday == 1 ... Sunday == 7  
### method: `now ()`
[tz] -&gt; new datetime with tz&#39;s local day and time.  
### method: `replace ()`
Return datetime with new specified fields.  
### method: `strftime ()`
format -&gt; strftime() style string.  
### method: `strptime ()`
string, format -&gt; new datetime parsed from a string (like time.strptime()).  
### method: `time ()`
Return time object with same time but with tzinfo=None.  
### method: `timetuple ()`
Return time tuple, compatible with time.localtime().  
### method: `timetz ()`
Return time object with same time and tzinfo.  
### method: `today ()`
Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).  
### method: `toordinal ()`
Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.  
### method: `tzname ()`
Return self.tzinfo.tzname(self).  
### method: `utcfromtimestamp ()`
timestamp -&gt; UTC datetime from a POSIX timestamp (like time.time()).  
### method: `utcnow ()`
Return a new datetime representing UTC day and time.  
### method: `utcoffset ()`
Return self.tzinfo.utcoffset(self).  
### method: `utctimetuple ()`
Return UTC time tuple, compatible with time.localtime().  
### method: `weekday ()`
Return the day of the week represented by the date.  
Monday == 0 ... Sunday == 6  
##   class: `JobOutputParseError`
  
Raise when failed to parse the output data for jobs  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `Job`
  
Job class, defining a job in a process  
  
### method: `__init__ (self, index, proc)`
  
Constructor  

- **params:**  
`index`:   The index of the job in a process  
`proc`:    The process  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_indexIndicator (self)`
  
Get the index indicator in the log  

- **returns:**  
The &quot;[001/100]&quot; like indicator  
  
### method: `_linkInfile (self, orgfile)`
  
Create links for input files  

- **params:**  
`orgfile`: The original input file  

- **returns:**  
The link to the original file.  
  
### method: `_prepInput (self)`
  
Prepare input, create link to input files and set other placeholders  
  
### method: `_prepOutput (self)`
  
Build the output data.  
Output could be:  
1. list: `[&#39;output:var:{{input}}&#39;, &#39;outfile:file:{{infile.bn}}.txt&#39;]`  
or you can ignore the name if you don&#39;t put it in script:  
`[&#39;var:{{input}}&#39;, &#39;path:{{infile.bn}}.txt&#39;]`  
or even (only var type can be ignored):  
`[&#39;{{input}}&#39;, &#39;file:{{infile.bn}}.txt&#39;]`  
2. str : `&#39;output:var:{{input}}, outfile:file:{{infile.bn}}.txt&#39;`  
3. OrderedDict: `{&quot;output:var:{{input}}&quot;: channel1, &quot;outfile:file:{{infile.bn}}.txt&quot;: channel2}`  
or    `{&quot;output:var:{{input}}, output:file:{{infile.bn}}.txt&quot; : channel3}`  
for 1,2 channels will be the property channel for this proc (i.e. p.channel)  
  
### method: `_prepScript (self)`
  
Build the script, interpret the placeholders  
  
### method: `_reportItem (self, key, maxlen, data, loglevel)`
  
Report the item on logs  

- **params:**  
`key`: The key of the item  
`maxlen`: The max length of the key  
`data`: The data of the item  
`loglevel`: The log level  
  
### method: `cache (self)`
  
Truly cache the job (by signature)  
  
### method: `checkOutfiles (self, expect)`
  
Check whether output files are generated, if not, add - to rc.  
  
### method: `done (self)`
  
Do some cleanup when job finished  
  
### method: `export (self)`
  
Export the output files  
  
### method: `init (self)`
  
Initiate a job, make directory and prepare input, output and script.  
  
### method: `isExptCached (self)`
  
Prepare to use export files as cached information  
True if succeed, otherwise False  
  
### method: `isTrulyCached (self)`
  
Check whether a job is truly cached (by signature)  
  
### method: `pid (self, val)`
  
Get/Set the job id (pid or the id from queue system)  

- **params:**  
`val`: The id to be set  
  
### method: `rc (self, val)`
  
Get/Set the return code  

- **params:**  
`val`: The return code to be set. If it is None, return the return code. Default: `None`  
If val == -1000: the return code will be negative of current one. 0 will be &#39;-0&#39;  

- **returns:**  
The return code if `val` is `None`  
If rcfile does not exist or is empty, return 9999, otherwise return -rc  
A negative rc (including -0) means output files not generated  
  
### method: `report (self)`
  
Report the job information to logger  
  
### method: `reset (self, retry)`
  
Clear the intermediate files and output files  
  
### method: `showError (self, totalfailed)`
  
Show the error message if the job failed.  
  
### method: `signature (self)`
  
Calculate the signature of the job based on the input/output and the script  

- **returns:**  
The signature of the job  
  
### method: `succeed (self)`
  
Tell if the job is successful by return code, and output file expectations.  

- **returns:**  
True if succeed else False  
  
# + module: pyppl.jobmgr
  
##   function: `JoinableQueue (maxsize)`
  
Returns a queue object  
  
##   class: `Jobmgr`
  
Job Manager  
  
### method: `__init__ (self, proc, runner)`
  
Job manager constructor  

- **params:**  
`proc`     : The process  
`runner`   : The runner class  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_exit (self)`
  
### method: `allJobsDone (self)`
  
Tell whether all jobs are done.  
No need to lock as it only runs in one process (the watcher process)  

- **returns:**  
`True` if all jobs are done else `False`  
  
### method: `canSubmit (self)`
  
Tell whether we can submit jobs.  

- **returns:**  
`True` if we can, otherwise `False`  
  
### method: `halt (self, halt_anyway)`
  
Halt the pipeline if needed  
  
### method: `progressbar (self, jid, loglevel)`
  
### method: `run (self)`
  
Start to run the jobs  
  
### method: `runPool (self, rq, sq)`
  
The pool to run jobs (wait jobs to be done)  

- **params:**  
`rq`: The run queue  
`sq`: The submit queue  
  
### method: `submitPool (self, sq)`
  
The pool to submit jobs  

- **params:**  
`sq`: The submit queue  
  
### method: `watchPool (self, rq, sq)`
  
The watchdog, checking whether all jobs are done.  
  
##   class: `Process`
  
Process objects represent activity that is run in a separate process  
  
The class is analagous to `threading.Thread`  
  
### method: `__init__ (self, group, target, name, args, kwargs)`
  
### method: `__repr__ (self)`
  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_bootstrap (self)`
  
### method: `is_alive (self)`
  
Return whether process is alive  
  
### method: `join (self, timeout)`
  
Wait until child process terminates  
  
### method: `run (self)`
  
Method to be run in sub-process; can be overridden in sub-class  
  
### method: `start (self)`
  
Start child process  
  
### method: `terminate (self)`
  
Terminate process; sends SIGTERM signal or uses TerminateProcess()  
  
##   function: `Lock ()`
  
Returns a non-recursive lock object  
  
##   function: `Array (typecode_or_type, size_or_initializer, **kwds)`
  
Returns a synchronized shared array  
  
# + module: pyppl.logger
  
A customized logger for pyppl  
  
##   class: `Box`
  
Allow dot operation for OrderedDict  
  
### method: `_OrderedDict__update (*args, **kwds)`
D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
In either case, this is followed by: for k, v in F.items(): D[k] = v  
  
### method: `__cmp__ ()`
x.__cmp__(y) &lt;==&gt; cmp(x,y)  
### method: `__contains__ ()`
D.__contains__(k) -&gt; True if D has a key k, else False  
### method: `__delitem__ (self, key, dict_delitem)`
od.__delitem__(y) &lt;==&gt; del od[y]  
### method: `__ge__ ()`
x.__ge__(y) &lt;==&gt; x&gt;=y  
### method: `__getattr__ (self, name)`
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__gt__ ()`
x.__gt__(y) &lt;==&gt; x&gt;y  
### method: `__init__ (*args, **kwds)`
Initialize an ordered dictionary.  The signature is the same as  
regular dictionaries, but keyword arguments are not recommended because  
their insertion order is arbitrary.  
  
  
### method: `__iter__ (self)`
od.__iter__() &lt;==&gt; iter(od)  
### method: `__le__ ()`
x.__le__(y) &lt;==&gt; x&lt;=y  
### method: `__len__ ()`
x.__len__() &lt;==&gt; len(x)  
### method: `__lt__ ()`
x.__lt__(y) &lt;==&gt; x&lt;y  
### method: `__repr__ (self, _repr_running)`
od.__repr__() &lt;==&gt; repr(od)  
### method: `__reversed__ (self)`
od.__reversed__() &lt;==&gt; reversed(od)  
### method: `__setattr__ (self, name, val)`
  
### method: `__setitem__ (self, key, value, dict_setitem)`
od.__setitem__(i, y) &lt;==&gt; od[i]=y  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `clear (self)`
od.clear() -&gt; None.  Remove all items from od.  
### method: `copy (self)`
od.copy() -&gt; a shallow copy of od  
### method: `fromkeys (cls, iterable, value)`
OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.  
If not specified, the value defaults to None.  
  
  
### method: `get ()`
D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.  
### method: `has_key ()`
D.has_key(k) -&gt; True if D has a key k, else False  
### method: `items (self)`
od.items() -&gt; list of (key, value) pairs in od  
### method: `iteritems (self)`
od.iteritems -&gt; an iterator over the (key, value) pairs in od  
### method: `iterkeys (self)`
od.iterkeys() -&gt; an iterator over the keys in od  
### method: `itervalues (self)`
od.itervalues -&gt; an iterator over the values in od  
### method: `keys (self)`
od.keys() -&gt; list of keys in od  
### method: `pop (self, key, default)`
od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding  
value.  If key is not found, d is returned if given, otherwise KeyError  
is raised.  
  
  
### method: `popitem (self, last)`
od.popitem() -&gt; (k, v), return and remove a (key, value) pair.  
Pairs are returned in LIFO order if last is true or FIFO order if false.  
  
  
### method: `setdefault (self, key, default)`
od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od  
### method: `update (*args, **kwds)`
D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
In either case, this is followed by: for k, v in F.items(): D[k] = v  
  
### method: `values (self)`
od.values() -&gt; list of values in od  
### method: `viewitems (self)`
od.viewitems() -&gt; a set-like object providing a view on od&#39;s items  
### method: `viewkeys (self)`
od.viewkeys() -&gt; a set-like object providing a view on od&#39;s keys  
### method: `viewvalues (self)`
od.viewvalues() -&gt; an object providing a view on od&#39;s values  
##   class: `PyPPLStreamHandler`
  
PyPPL stream log handler.  
To implement the progress bar for JOBONE and SUBMIT logs.  
  
### method: `__init__ (self, stream)`
  
Constructor  

- **params:**  
`stream`: The stream  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_emit (self, record, terminator)`
  
Helper function implementing a python2,3-compatible emit.  
Allow to add &quot;  
&quot; or &quot;
&quot; as terminator.  
  
### method: `acquire (self)`
  
Acquire the I/O thread lock.  
  
### method: `addFilter (self, filter)`
  
Add the specified filter to this handler.  
  
### method: `close (self)`
  
Tidy up any resources used by the handler.  
  
This version removes the handler from an internal map of handlers,  
_handlers, which is used for handler lookup by name. Subclasses  
should ensure that this gets called from overridden close()  
methods.  
  
### method: `createLock (self)`
  
Acquire a thread lock for serializing access to the underlying I/O.  
  
### method: `emit (self, record)`
  
Emit the record.  
  
### method: `filter (self, record)`
  
Determine if a record is loggable by consulting all the filters.  
  
The default is to allow the record to be logged; any filter can veto  
this and the record is then dropped. Returns a zero value if a record  
is to be dropped, else non-zero.  
  
### method: `flush (self)`
  
Flushes the stream.  
  
### method: `format (self, record)`
  
Format the specified record.  
  
If a formatter is set, use it. Otherwise, use the default formatter  
for the module.  
  
### method: `get_name (self)`
  
### method: `handle (self, record)`
  
Conditionally emit the specified logging record.  
  
Emission depends on filters which may have been added to the handler.  
Wrap the actual emission of the record with acquisition/release of  
the I/O thread lock. Returns whether the filter passed the record for  
emission.  
  
### method: `handleError (self, record)`
  
Handle errors which occur during an emit() call.  
  
This method should be called from handlers when an exception is  
encountered during an emit() call. If raiseExceptions is false,  
exceptions get silently ignored. This is what is mostly wanted  
for a logging system - most users will not care about errors in  
the logging system, they are more interested in application errors.  
You could, however, replace this with a custom handler if you wish.  
The record which was being processed is passed in to this method.  
  
### method: `release (self)`
  
Release the I/O thread lock.  
  
### method: `removeFilter (self, filter)`
  
Remove the specified filter from this handler.  
  
### method: `setFormatter (self, fmt)`
  
Set the formatter for this handler.  
  
### method: `setLevel (self, level)`
  
Set the logging level of this handler.  
  
### method: `set_name (self, name)`
  
##   class: `LoggerThemeError`
  
Theme errors for logger  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `PyPPLLogFormatter`
  
logging formatter for pyppl  
  
### method: `__init__ (self, fmt, theme, secondary)`
  
Constructor  

- **params:**  
`fmt`      : The format  
`theme`    : The theme  
`secondary`: Whether this is a secondary formatter or not (another formatter applied before this).  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `converter ()`
localtime([seconds]) -&gt; (tm_year,tm_mon,tm_mday,tm_hour,tm_min,  
tm_sec,tm_wday,tm_yday,tm_isdst)  
  
Convert seconds since the Epoch to a time tuple expressing local time.  
When &#39;seconds&#39; is not passed in, convert the current time instead.  
### method: `format (self, record)`
  
Format the record  

- **params:**  
`record`: The log record  

- **returns:**  
The formatted record  
  
### method: `formatException (self, ei)`
  
Format and return the specified exception information as a string.  
  
This default implementation just uses  
traceback.print_exception()  
  
### method: `formatTime (self, record, datefmt)`
  
Return the creation time of the specified LogRecord as formatted text.  
  
This method should be called from format() by a formatter which  
wants to make use of a formatted time. This method can be overridden  
in formatters to provide for any specific requirement, but the  
basic behaviour is as follows: if datefmt (a string) is specified,  
it is used with time.strftime() to format the creation time of the  
record. Otherwise, the ISO8601 format is used. The resulting  
string is returned. This function uses a user-configurable function  
to convert the creation time to a tuple. By default, time.localtime()  
is used; to change this for a particular formatter instance, set the  
&#39;converter&#39; attribute to a function with the same signature as  
time.localtime() or time.gmtime(). To change it for all formatters,  
for example if you want all logging times to be shown in GMT,  
set the &#39;converter&#39; attribute in the Formatter class.  
  
### method: `usesTime (self)`
  
Check if the format uses the creation time of the record.  
  
##   class: `PyPPLLogFilter`
  
logging filter by levels (flags)  
  
### method: `__init__ (self, name, lvls, lvldiff)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `filter (self, record)`
  
##   function: `_getLevel (record)`
  
Get the flags of a record  

- **params:**  
`record`:  The logging record  
  
##   function: `Value (typecode_or_type, *args, **kwds)`
  
Returns a synchronized shared object  
  
##   function: `_formatTheme (theme)`
  
Make them in the standard form with bgcolor and fgcolor in raw terminal color strings  
If the theme is read from file, try to translate &quot;COLORS.xxx&quot; to terminal color strings  

- **params:**  
`theme`: The theme  

- **returns:**  
The formatted colors  
  
##   function: `_getColorFromTheme (level, theme)`
  
Get colors from a them  

- **params:**  
`level`: Our own log record level  
`theme`: The theme  

- **returns:**  
The colors  
  
##   class: `TemplatePyPPL`
  
Built-in template wrapper.  
  
### method: `__init__ (self, source, **envs)`
  
Initiate the engine with source and envs  

- **params:**  
`source`: The souce text  
`envs`: The env data  
  
### method: `__repr__ (self)`
  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ (self)`
  
### method: `_render (self, data)`
  
Render the template  

- **params:**  
`data`: The data used for rendering  

- **returns:**  
The rendered string  
  
### method: `registerEnvs (self, **envs)`
  
### method: `render (self, data)`
  
##   function: `getLogger (levels, theme, logfile, lvldiff, pbar, name)`
  
Get the default logger  

- **params:**  
`levels`: The log levels(tags), default: basic  
`theme`:  The theme of the logs on terminal. Default: True (default theme will be used)  
- False to disable theme  
`logfile`:The log file. Default: None (don&#39;t white to log file)  
`lvldiff`:The diff levels for log  
- [&quot;-depends&quot;, &quot;jobdone&quot;, &quot;+debug&quot;]: show jobdone, hide depends and debug  
`name`:   The name of the logger, default: PyPPL  

- **returns:**  
The logger  
  
# + module: pyppl.parameters
  
##   class: `Box`
  
Allow dot operation for OrderedDict  
  
### method: `_OrderedDict__update (*args, **kwds)`
D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
In either case, this is followed by: for k, v in F.items(): D[k] = v  
  
### method: `__cmp__ ()`
x.__cmp__(y) &lt;==&gt; cmp(x,y)  
### method: `__contains__ ()`
D.__contains__(k) -&gt; True if D has a key k, else False  
### method: `__delitem__ (self, key, dict_delitem)`
od.__delitem__(y) &lt;==&gt; del od[y]  
### method: `__ge__ ()`
x.__ge__(y) &lt;==&gt; x&gt;=y  
### method: `__getattr__ (self, name)`
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__gt__ ()`
x.__gt__(y) &lt;==&gt; x&gt;y  
### method: `__init__ (*args, **kwds)`
Initialize an ordered dictionary.  The signature is the same as  
regular dictionaries, but keyword arguments are not recommended because  
their insertion order is arbitrary.  
  
  
### method: `__iter__ (self)`
od.__iter__() &lt;==&gt; iter(od)  
### method: `__le__ ()`
x.__le__(y) &lt;==&gt; x&lt;=y  
### method: `__len__ ()`
x.__len__() &lt;==&gt; len(x)  
### method: `__lt__ ()`
x.__lt__(y) &lt;==&gt; x&lt;y  
### method: `__repr__ (self, _repr_running)`
od.__repr__() &lt;==&gt; repr(od)  
### method: `__reversed__ (self)`
od.__reversed__() &lt;==&gt; reversed(od)  
### method: `__setattr__ (self, name, val)`
  
### method: `__setitem__ (self, key, value, dict_setitem)`
od.__setitem__(i, y) &lt;==&gt; od[i]=y  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `clear (self)`
od.clear() -&gt; None.  Remove all items from od.  
### method: `copy (self)`
od.copy() -&gt; a shallow copy of od  
### method: `fromkeys (cls, iterable, value)`
OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.  
If not specified, the value defaults to None.  
  
  
### method: `get ()`
D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.  
### method: `has_key ()`
D.has_key(k) -&gt; True if D has a key k, else False  
### method: `items (self)`
od.items() -&gt; list of (key, value) pairs in od  
### method: `iteritems (self)`
od.iteritems -&gt; an iterator over the (key, value) pairs in od  
### method: `iterkeys (self)`
od.iterkeys() -&gt; an iterator over the keys in od  
### method: `itervalues (self)`
od.itervalues -&gt; an iterator over the values in od  
### method: `keys (self)`
od.keys() -&gt; list of keys in od  
### method: `pop (self, key, default)`
od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding  
value.  If key is not found, d is returned if given, otherwise KeyError  
is raised.  
  
  
### method: `popitem (self, last)`
od.popitem() -&gt; (k, v), return and remove a (key, value) pair.  
Pairs are returned in LIFO order if last is true or FIFO order if false.  
  
  
### method: `setdefault (self, key, default)`
od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od  
### method: `update (*args, **kwds)`
D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
In either case, this is followed by: for k, v in F.items(): D[k] = v  
  
### method: `values (self)`
od.values() -&gt; list of values in od  
### method: `viewitems (self)`
od.viewitems() -&gt; a set-like object providing a view on od&#39;s items  
### method: `viewkeys (self)`
od.viewkeys() -&gt; a set-like object providing a view on od&#39;s keys  
### method: `viewvalues (self)`
od.viewvalues() -&gt; an object providing a view on od&#39;s values  
##   class: `Commands`
  
Support sub-command for command line argument parse.  
  
### method: `__getattr__ (self, name)`
  
### method: `__getitem__ (self, name)`
  
### method: `__init__ (self, theme)`
  
Constructor  

- **params:**  
`theme`: The theme  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ (self, name, value)`
  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_setDesc (self, desc)`
  
Set the description  

- **params:**  
`desc`: The description  
  
### method: `_setHcmd (self, hcmd)`
  
Set the help command  

- **params:**  
`hcmd`: The help command  
  
### method: `_setTheme (self, theme)`
  
Set the theme  

- **params:**  
`theme`: The theme  
  
### method: `help (self, error, printNexit)`
  
Construct the help page  

- **params:**  
`error`: the error message  
`printNexit`: print the help page and exit instead of return the help information  

- **returns:**  
The help information if `printNexit` is `False`  
  
### method: `parse (self, args, arbi)`
  
Parse the arguments.  

- **params:**  
`args`: The arguments (list). `sys.argv[1:]` will be used if it is `None`.  
`arbi`: Whether do an arbitrary parse. If True, options don&#39;t need to be defined. Default: `False`  

- **returns:**  
A `tuple` with first element the subcommand and second the parameters being parsed.  
  
##   class: `Parameters`
  
A set of parameters  
  
### method: `__call__ (self, option, value)`
  
Set options values in `self._props`.  
Will be deprecated in the future!  

- **params:**  
`option`: The key of the option  
`value` : The value of the option  
`excl`  : The value is used to exclude (only for `hopts`)  

- **returns:**  
`self`  
  
### method: `__getattr__ (self, name)`
  
### method: `__getitem__ (self, name)`
  
### method: `__init__ (self, command, theme)`
  
Constructor  

- **params:**  
`command`: The sub-command  
`theme`: The theme  
  
### method: `__repr__ (self)`
  
### method: `__setattr__ (self, name, value)`
  
### method: `__setitem__ (self, name, value)`
  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### staticmethod: `_coerceValue (value, t)`
  
Coerce a value to another type.  

- **params:**  
`value`: The value  
`t`: The type  
  
### method: `_parseName (self, argname)`
  
If `argname` is the name of an option  

- **params:**  
`argname`: The argname  

- **returns:**  
`an`: clean argument name  
`at`: normalized argument type  
`av`: the argument value, if `argname` is like: `-a=1`  
  
### method: `_putValue (self, argname, argtype, argval, arbi)`
  
Save the values.  

- **params:**  
`argname`: The option name  
`argtype`: The parsed type  
`argval`:  The option value  
`arbi`:    Whether allow pass options arbitrarily (without definition)  

- **return:**  
`True` if value append to a list option successfully, otherwise `False`  
  
### method: `_setDesc (self, desc)`
  
Set the description  

- **params:**  
`desc`: The description  
  
### method: `_setHbald (self, hbald)`
  
Set if we should show help information if no arguments passed.  

- **params:**  
`hbald`: The flag. show if True else hide. Default: `True`  
  
### method: `_setHopts (self, hopts)`
  
Set the help options  

- **params:**  
`hopts`: The help options  
  
### method: `_setPrefix (self, prefix)`
  
Set the option prefix  

- **params:**  
`prefix`: The prefix  
  
### method: `_setTheme (self, theme)`
  
Set the theme  

- **params:**  
`theme`: The theme  
  
### method: `_setUsage (self, usage)`
  
Set the usage  

- **params:**  
`usage`: The usage  
  
### method: `_shouldPrintHelp (self, args)`
  
### method: `asDict (self)`
  
Convert the parameters to Box object  

- **returns:**  
The Box object  
  
### method: `help (self, error, printNexit)`
  
Calculate the help page  

- **params:**  
`error`: The error message to show before the help information. Default: `&#39;&#39;`  
`printNexit`: Print the help page and exit the program? Default: `False` (return the help information)  

- **return:**  
The help information  
  
### method: `loadDict (self, dictVar, show)`
  
Load parameters from a dict  

- **params:**  
`dictVar`: The dict variable.  
- Properties are set by &quot;&lt;param&gt;.required&quot;, &quot;&lt;param&gt;.show&quot;, ...  
`show`:    Whether these parameters should be shown in help information  
- Default: False (don&#39;t show parameter from config object in help page)  
- It&#39;ll be overwritten by the `show` property inside dict variable.  
- If it is None, will inherit the param&#39;s show value  
  
### method: `loadFile (self, cfgfile, show)`
  
Load parameters from a json/config file  
If the file name ends with &#39;.json&#39;, `json.load` will be used,  
otherwise, `ConfigParser` will be used.  
For config file other than json, a section name is needed, whatever it is.  

- **params:**  
`cfgfile`: The config file  
`show`:    Whether these parameters should be shown in help information  
- Default: False (don&#39;t show parameter from config file in help page)  
- It&#39;ll be overwritten by the `show` property inside the config file.  
  
### method: `parse (self, args, arbi)`
  
Parse the arguments.  

- **params:**  
`args`: The arguments (list). `sys.argv[1:]` will be used if it is `None`.  
`arbi`: Whether do an arbitrary parse. If True, options don&#39;t need to be defined. Default: `False`  

- **returns:**  
A `Box`/`dict` object containing all option names and values.  
  
##   class: `ParametersLoadError`
  
Error loading dict to Parameters  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ParameterNameError`
  
Malformed name not allowed  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ParameterTypeError`
  
Unable to set type  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `HelpAssembler`
  
A helper class to help assembling the help information page.  

- **staticvars**  
`MAXPAGEWIDTH`: the max width of the help page, not including the leading space  
`MAXOPTWIDTH` : the max width of the option name (include the type and placeholder, but not the leading space)  
`THEMES`      : the themes  
  
### method: `__init__ (self, prog, theme)`
  
Constructor  

- **params:**  
`prog`: The program name  
`theme`: The theme. Could be a name of `THEMES`, or a dict of a custom theme.  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### staticmethod: `_calcwidth (helps, progname)`
  
### staticmethod: `_reallen (msg, progname)`
  
### method: `assemble (self, helps, progname)`
  
Assemble the whole help page.  

- **params:**  
`helps`: The help items. A list with plain strings or tuples of 3 elements, which  
will be treated as option name, option type/placeholder and option descriptions.  
`progname`: The program name used to replace &#39;{prog}&#39; with.  

- **returns:**  
lines (`list`) of the help information.  
  
### method: `error (self, msg)`
  
Render an error message  

- **params:**  
`msg`: The error message  
  
### method: `optdesc (self, msg)`
  
Render the option descriptions  

- **params:**  
`msg`: the option descriptions  
  
### method: `optname (self, msg)`
  
Render the option name  

- **params:**  
`msg`: The option name  
  
### method: `opttype (self, msg)`
  
Render the option type or placeholder  

- **params:**  
`msg`: the option type or placeholder  
  
### method: `plain (self, msg)`
  
Render a plain message  

- **params:**  
`msg`: the message  
  
### method: `prog (self, prog)`
  
Render the program name  

- **params:**  
`msg`: The program name  
  
### method: `title (self, msg)`
  
Render an section title  

- **params:**  
`msg`: The section title  
  
### method: `warning (self, msg)`
  
Render an warning message  

- **params:**  
`msg`: The warning message  
  
##   class: `Parameter`
  
The class for a single parameter  
  
### method: `__getattr__ (self, name)`
  
### method: `__init__ (self, name, value)`
  
Constructor  

- **params:**  
`name`:  The name of the parameter  
`value`: The initial value of the parameter  
  
### method: `__repr__ (self)`
  
### method: `__setattr__ (self, name, value)`
  
### method: `__str__ (self)`
  
### method: `_forceType (self)`
  
Coerce the value to the type specified  
TypeError will be raised if error happens  
  
### method: `setDesc (self, d)`
  
Set the description of the parameter  

- **params:**  
`d`: The description  
  
### method: `setName (self, n)`
  
Set the name of the parameter  

- **params:**  
`n`: The name  
  
### method: `setRequired (self, r)`
  
Set whether this parameter is required  

- **params:**  
`r`: True if required else False. Default: True  
  
### method: `setShow (self, s)`
  
Set whether this parameter should be shown in help information  

- **params:**  
`s`: True if it shows else False. Default: True  
  
### method: `setType (self, t)`
  
Set the type of the parameter  

- **params:**  
`t`: The type of the value. Default: str  
- Note: str rather then &#39;str&#39;  
  
### method: `setValue (self, v)`
  
Set the value of the parameter  

- **params:**  
`v`: The value  
  
##   class: `ParametersParseError`
  
Error when parsing the parameters  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
# + module: pyppl.proctree
  
Manage process relations  
  
##   class: `ProcTreeProcExists`
  
Raise when two Procs with same id and tag defined  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, pn1, pn2)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `ProcNode`
  
The node for processes to manage relations between each other  
  
### method: `__init__ (self, proc)`
  
Constructor  

- **params:**  
`proc`: The `Proc` instance  
  
### method: `__repr__ (self)`
  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `sameIdTag (self, proc)`
  
Check if the process has the same id and tag with me.  

- **params:**  
`proc`: The `Proc` instance  

- **returns:**  
`True` if it is.  
`False` if not.  
  
##   class: `ProcTreeParseError`
  
Raise when failed to parse the tree  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
# + module: pyppl.runners.helpers
  
##   class: `Box`
  
Allow dot operation for OrderedDict  
  
### method: `_OrderedDict__update (*args, **kwds)`
D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
In either case, this is followed by: for k, v in F.items(): D[k] = v  
  
### method: `__cmp__ ()`
x.__cmp__(y) &lt;==&gt; cmp(x,y)  
### method: `__contains__ ()`
D.__contains__(k) -&gt; True if D has a key k, else False  
### method: `__delitem__ (self, key, dict_delitem)`
od.__delitem__(y) &lt;==&gt; del od[y]  
### method: `__ge__ ()`
x.__ge__(y) &lt;==&gt; x&gt;=y  
### method: `__getattr__ (self, name)`
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__gt__ ()`
x.__gt__(y) &lt;==&gt; x&gt;y  
### method: `__init__ (*args, **kwds)`
Initialize an ordered dictionary.  The signature is the same as  
regular dictionaries, but keyword arguments are not recommended because  
their insertion order is arbitrary.  
  
  
### method: `__iter__ (self)`
od.__iter__() &lt;==&gt; iter(od)  
### method: `__le__ ()`
x.__le__(y) &lt;==&gt; x&lt;=y  
### method: `__len__ ()`
x.__len__() &lt;==&gt; len(x)  
### method: `__lt__ ()`
x.__lt__(y) &lt;==&gt; x&lt;y  
### method: `__repr__ (self, _repr_running)`
od.__repr__() &lt;==&gt; repr(od)  
### method: `__reversed__ (self)`
od.__reversed__() &lt;==&gt; reversed(od)  
### method: `__setattr__ (self, name, val)`
  
### method: `__setitem__ (self, key, value, dict_setitem)`
od.__setitem__(i, y) &lt;==&gt; od[i]=y  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `clear (self)`
od.clear() -&gt; None.  Remove all items from od.  
### method: `copy (self)`
od.copy() -&gt; a shallow copy of od  
### method: `fromkeys (cls, iterable, value)`
OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.  
If not specified, the value defaults to None.  
  
  
### method: `get ()`
D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.  
### method: `has_key ()`
D.has_key(k) -&gt; True if D has a key k, else False  
### method: `items (self)`
od.items() -&gt; list of (key, value) pairs in od  
### method: `iteritems (self)`
od.iteritems -&gt; an iterator over the (key, value) pairs in od  
### method: `iterkeys (self)`
od.iterkeys() -&gt; an iterator over the keys in od  
### method: `itervalues (self)`
od.itervalues -&gt; an iterator over the values in od  
### method: `keys (self)`
od.keys() -&gt; list of keys in od  
### method: `pop (self, key, default)`
od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding  
value.  If key is not found, d is returned if given, otherwise KeyError  
is raised.  
  
  
### method: `popitem (self, last)`
od.popitem() -&gt; (k, v), return and remove a (key, value) pair.  
Pairs are returned in LIFO order if last is true or FIFO order if false.  
  
  
### method: `setdefault (self, key, default)`
od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od  
### method: `update (*args, **kwds)`
D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.  
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]  
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v  
In either case, this is followed by: for k, v in F.items(): D[k] = v  
  
### method: `values (self)`
od.values() -&gt; list of values in od  
### method: `viewitems (self)`
od.viewitems() -&gt; a set-like object providing a view on od&#39;s items  
### method: `viewkeys (self)`
od.viewkeys() -&gt; a set-like object providing a view on od&#39;s keys  
### method: `viewvalues (self)`
od.viewvalues() -&gt; an object providing a view on od&#39;s values  
##   class: `Helper`
  
A helper class for runners  
  
### method: `__init__ (self, script, cmds)`
  
Constructor  

- **params:**  
`script`: The script of the job  
`cmds`  : The original runner commands  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `alive (self)`
  
Tell if the job is alive  
  
### method: `kill (self)`
  
Kill the job  
  
### method: `run (self)`
  
Run the job, wait for the job to complete  
  
### method: `submit (self)`
  
Submit the job  
  
##   class: `SafeFs`
  
A thread-safe file system  
  

- **static variables:**  
  
`TMPDIR`: The default temporary directory to store lock files  
  
# file types  
`FILETYPE_UNKNOWN`  : Unknown file type  
`FILETYPE_NOENT`    : File does not exist  
`FILETYPE_NOENTLINK`: A dead link (a link links to a non-existent file.  
`FILETYPE_FILE`     : A regular file  
`FILETYPE_FILELINK` : A link to a regular file  
`FILETYPE_DIR`      : A regular directory  
`FILETYPE_DIRLINK`  : A link to a regular directory  
  
# relation of two files  
`FILES_DIFF_BOTHNOENT` : Two files are different and none of them exists  
`FILES_DIFF_NOENT1`    : Two files are different but file1 does not exists  
`FILES_DIFF_NOENT2`    : Two files are different but file2 does not exists  
`FILES_DIFF_BOTHENT`   : Two files are different and both of them exist  
`FILES_SAME_STRNOENT`  : Two files are the same string and it does not exist  
`FILES_SAME_STRENT`    : Two files are the same string and it exists  
`FILES_SAME_BOTHLINKS` : Two files link to one file  
`FILES_SAME_BOTHLINKS1`: File1 links to file2, file2 links to a regular file  
`FILES_SAME_BOTHLINKS2`: File2 links to file1, file1 links to a regular file  
`FILES_SAME_REAL1`     : File2 links to file1, which a regular file  
`FILES_SAME_REAL2`     : File1 links to file2, which a regular file  
  
`LOCK`: A global lock ensures the locks are locked at the same time  
  
### method: `__init__ (self, file1, file2, tmpdir)`
  
Constructor  

- **params:**  
`file1`:  File 1  
`file2`:  File 2. Default: `None`  
`tmpdir`: The temporary directory used to store lock files. Default: `None` (`SafeFs.TMPDIR`)  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### staticmethod: `_copy (file1, file2, overwrite, filetype1, filetype2)`
  
Copy a file or a directory  

- **params:**  
`file1`    : The source  
`file2`    : The destination  
`overwrite`: Overwrite the destination? Default: `True`  
`filetype1`: The file type of file1  
`filetype2`: The file type of file2  

- **returns:**  
`True` if succeed else `False`  
  
### staticmethod: `_dirmtime (filepath)`
  
Get the modified time of a directory recursively  

- **params:**  
`filepath`: The file path  

- **return`:**  
The most recent modified time  
  
### staticmethod: `_exists (filepath, filetype)`
  
Tell if a file exists  

- **params:**  
`filepath`: The source  
`filetype`: The file type of file2  

- **returns:**  
`True` if exists else `False`  
  
### staticmethod: `_filerel (file1, file2, filetype1, filetype2)`
  
Check the relations between file1 and file2.  

- **params:**  
`file1`: The first file  
`file2`: The second file  
`filetype1`: The file type of file1  
`filetype2`: The file type of file2  

- **returns:**  
`SafeFs.FILES_DIFF_BOTHNOENT`: they are different for whatever reason.  
`SafeFs.FILES_DIFF_NOENT1`   : they are different for whatever reason.  
`SafeFs.FILES_DIFF_NOENT2`   : they are different for whatever reason.  
`SafeFs.FILES_DIFF_BOTHENT`  : they are different for whatever reason.  
`SafeFs.FILES_SAME_STRENT`   : they are the same string and the file exists.  
`SafeFs.FILES_SAME_STRNOENT` : they are the same string but the file doesn&#39;t exist.  
`SafeFs.FILES_SAME_BOTHLINKS`: both of them are links to the same file.  
`SafeFs.FILES_SAME_REAL1`    : file1 is the real file, file2 is a link to it.  
`SafeFs.FILES_SAME_REAL2`    : file2 is the real file, file1 is a link to it.  
  
### staticmethod: `_filetype (filepath)`
  
Get the file type  

- **params:**  
`filepath`: The file path  

- **returns:**  
The file type (one of `SafeFs.FILETYPE_*`)  
  
### staticmethod: `_gz (file1, file2, overwrite, filetype1, filetype2)`
  
Gzip a file or tar gzip a directory  

- **params:**  
`file1`    : The source  
`file2`    : The destination  
`overwrite`: Overwrite the destination? Default: `True`  
`filetype1`: The file type of file1  
`filetype2`: The file type of file2  

- **returns:**  
`True` if succeed else `False`  
  
### staticmethod: `_link (file1, file2, overwrite, filetype1, filetype2)`
  
Create a symbolic link for the given file  

- **params:**  
`file1`    : The source  
`file2`    : The destination  
`overwrite`: Overwrite the destination? Default: `True`  
`filetype1`: The file type of file1  
`filetype2`: The file type of file2  

- **returns:**  
`True` if succeed else `False`  
  
### method: `_lock (self, lock1, lock2)`
  
Lock the file slots  

- **params:**  
`lock1`: Which slots to lock for file1  
- `both`: Both the file itself and the realpath of it (if it is a link)  
- `real`: Only the realpath of it  
- `self`: Just the file itself  
`lock2`: Which slots to lock for file2  
  
### staticmethod: `_lockfile (filepath, real, filetype, tmpdir)`
  
Get the path of lockfile of a file  

- **params:**  
`filepath`: The file  
`real`    : Use the filepath itself or the realpath (if filepath is a link). Default: `True`  
`filetype`: The filetype, if not provided, will be fetched by `SafeFs._filetype`  
`tmpdir`  : The tmpdir storing the lock files.  

- **returns:**  
The path of the lock file  
  
### staticmethod: `_move (file1, file2, overwrite, filetype1, filetype2)`
  
Move a file  

- **params:**  
`file1`    : The source  
`file2`    : The destination  
`overwrite`: Overwrite the destination? Default: `True`  
`filetype1`: The file type of file1  
`filetype2`: The file type of file2  

- **returns:**  
`True` if succeed else `False`  
  
### staticmethod: `_remove (filepath, filetype)`
  
Remove an entry  

- **params:**  
`filepath`: The path of the entry  
`filetype`: The file type  

- **returns:**  
`True` if succeed else `False`  
  
### staticmethod: `_ungz (file1, file2, overwrite, filetype1, filetype2)`
  
Decompress a gzip file or tar-gzip file  

- **params:**  
`file1`    : The source  
`file2`    : The destination  
`overwrite`: Overwrite the destination? Default: `True`  
`filetype1`: The file type of file1  
`filetype2`: The file type of file2  

- **returns:**  
`True` if succeed else `False`  
  
### method: `_unlock (self)`
  
Unlock the slots  
  
### staticmethod: `basename (filepath)`
  
Get the basename of a file  
If it is a directory like &#39;/a/b/c/&#39;, return `c`  

- **params:**  
`filepath`: The file path  

- **returns:**  
The basename  
  
### method: `chmodX (self)`
  
Convert file1 to executable or add extract shebang to cmd line  

- **returns:**  
A list with or without the path of the interpreter as the first element and the script file as the last element  
  
### method: `copy (self, overwrite, callback)`
  
Copy file1 to file2 thread-safely  

- **params:**  
`overwrite`: Allow overwrting file2? Default: `True`  
`callback`:  The callback. arguments:  
- `r` :  Whether the file exists  
- `fs`:  This instance  

- **returns:**  
`True` if succeed else `False`  
  
### method: `exists (self, callback)`
  
Tell if file1 exists thread-safely  

- **params:**  
`callback`: The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  

- **returns:**  
`True` if exists else `False`  
  
### method: `filesig (self, dirsig)`
  
Generate a signature for a file  

- **params:**  
`dirsig`: Whether expand the directory? Default: True  

- **returns:**  
The signature  
  
### staticmethod: `flush (fd, lastmsg, end)`
  
Flush a file descriptor  

- **params:**  
`fd`     : The file handler  
`lastmsg`: The remaining content of last flush  
`end`    : The file ends? Default: `False`  
  
### method: `gz (self, overwrite, callback)`
  
Gzip file1 (tar-gzip if file1 is a directory) to file2 in a thread-safe way  

- **params:**  
`overwrite`: Allow overwrting file2? Default: `True`  
`callback`:  The callback. arguments:  
- `r` :  Whether the file exists  
- `fs`:  This instance  

- **returns:**  
`True` if succeed else `False`  
  
### method: `link (self, overwrite, callback)`
  
Link file1 to file2 thread-safely  

- **params:**  
`overwrite`: Allow overwrting file2? Default: `True`  
`callback`:  The callback. arguments:  
- `r` :  Whether the file exists  
- `fs`:  This instance  

- **returns:**  
`True` if succeed else `False`  
  
### method: `move (self, overwrite, callback)`
  
Move file1 to file2 thread-safely  

- **params:**  
`overwrite`: Allow overwrting file2? Default: `True`  
`callback`:  The callback. arguments:  
- `r` :  Whether the file exists  
- `fs`:  This instance  

- **returns:**  
`True` if succeed else `False`  
  
### method: `moveWithLink (self, overwrite, callback)`
  
Move file1 to file2 and link file2 to file1 in a thread-safe way  

- **params:**  
`overwrite`: Allow overwrting file2? Default: `True`  
`callback`:  The callback. arguments:  
- `r` :  Whether the file exists  
- `fs`:  This instance  

- **returns:**  
`True` if succeed else `False`  
  
### method: `remove (self, callback)`
  
Remove file1 thread-safely  

- **params:**  
`callback`: The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  

- **returns:**  
`True` if succeed else `False`  
  
### method: `samefile (self, callback)`
  
Tell if file1 and file2 are the same file in a thread-safe way  

- **params:**  
`callback`: The callback. arguments:  
- `r` : Whether the file exists  
- `fs`: This instance  

- **returns:**  
`True` if they are the same file else `False`  
  
### method: `ungz (self, overwrite, callback)`
  
Ungzip file1 (tar-ungzip if file1 tar-gzipped to file2 in a thread-safe way  

- **params:**  
`overwrite`: Allow overwrting file2? Default: `True`  
`callback`:  The callback. arguments:  
- `r` :  Whether the file exists  
- `fs`:  This instance  

- **returns:**  
`True` if succeed else `False`  
  
# + module: pyppl.runners.runner
  
The base runner class  
  
##   class: `Runner`
  
The base runner class  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
##   function: `Lock ()`
  
Returns a non-recursive lock object  
  
##   function: `Value (typecode_or_type, *args, **kwds)`
  
Returns a synchronized shared object  
  
##   function: `list2cmdline (seq)`
  
Translate a sequence of arguments into a command line  
string, using the same rules as the MS C runtime:  
  
1) Arguments are delimited by white space, which is either a  
space or a tab.  
  
2) A string surrounded by double quotation marks is  
interpreted as a single argument, regardless of white space  
contained within.  A quoted string can be embedded in an  
argument.  
  
3) A double quotation mark preceded by a backslash is  
interpreted as a literal double quotation mark.  
  
4) Backslashes are interpreted literally, unless they  
immediately precede a double quotation mark.  
  
5) If backslashes immediately precede a double quotation mark,  
every pair of backslashes is interpreted as a literal  
backslash.  If the number of backslashes is odd, the last  
backslash escapes the next double quotation mark as  
described in rule 3.  
  
# + module: pyppl.runners.runner_dry
  
# Dry runner  
  
##   class: `Runner`
  
The base runner class  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
##   class: `RunnerDry`
  
The dry runner  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
Do some cleanup work when jobs finish  
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
# + module: pyppl.runners.runner_local
  
# A runner wrapper for a single script  
# Author: pwwang@pwwang.com  
# Examples:  
#	@see runner.unittest.py  
  
##   class: `Runner`
  
The base runner class  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
##   class: `RunnerLocal`
  
Constructor  

- **params:**  
`job`:    The job object  
`config`: The properties of the process  
  
### method: `__init__ (self, job)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
# + module: pyppl.runners.runner_sge
  
##   class: `Runner`
  
The base runner class  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
##   class: `RunnerSge`
  
The sge runner  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
`config`: The properties of the process  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
# + module: pyppl.runners.runner_slurm
  
##   class: `Runner`
  
The base runner class  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
##   class: `RunnerSlurm`
  
The slurm runner  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
`config`: The properties of the process  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
# + module: pyppl.runners.runner_ssh
  
##   class: `Runner`
  
The base runner class  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
##   function: `Lock ()`
  
Returns a non-recursive lock object  
  
##   function: `Value (typecode_or_type, *args, **kwds)`
  
Returns a synchronized shared object  
  
##   class: `RunnerSsh`
  
The ssh runner  
  

- **static variables:**  
`SERVERID`: The incremental number used to calculate which server should be used.  
- Don&#39;t touch unless you know what&#39;s going on!  
  
  
### method: `__init__ (self, job)`
  
Constructor  

- **params:**  
`job`:    The job object  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
### method: `_flush (self, fout, ferr, lastout, lasterr, end)`
  
Flush stdout/stderr  

- **params:**  
`fout`: The stdout file handler  
`ferr`: The stderr file handler  
`lastout`: The leftovers of previously readlines of stdout  
`lasterr`: The leftovers of previously readlines of stderr  
`end`: Whether this is the last time to flush  
  
### method: `finish (self)`
  
### method: `getpid (self)`
  
Get the job id  
  
### method: `isRunning (self)`
  
Try to tell whether the job is still running.  

- **returns:**  
`True` if yes, otherwise `False`  
  
### staticmethod: `isServerAlive (server, key)`
  
### method: `kill (self)`
  
Try to kill the running jobs if I am exiting  
  
### method: `retry (self)`
  
### method: `run (self)`
  

- **returns:**  
True: success/fail  
False: needs retry  
  
### method: `submit (self)`
  
Try to submit the job  
  
##   function: `Array (typecode_or_type, size_or_initializer, **kwds)`
  
Returns a synchronized shared array  
  
##   class: `RunnerSshError`
  
Raise when failed to initiate RunnerSsh  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
# + module: pyppl.templates.template
  
##   function: `asStr (s, encoding)`
  
Convert everything (str, unicode, bytes) to str with python2, python3 compatiblity  
  
# + module: pyppl.templates.template_jinja2
  
##   class: `TemplateJinja2`
  
Jinja2 template wrapper  
  
### method: `__init__ (self, source, **envs)`
  
Initiate the engine with source and envs  

- **params:**  
`source`: The souce text  
`envs`: The env data  
  
### method: `__repr__ (self)`
  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ (self)`
  
### method: `_render (self, data)`
  
Render the template  

- **params:**  
`data`: The data used for rendering  

- **returns:**  
The rendered string  
  
### method: `registerEnvs (self, **envs)`
  
### method: `render (self, data)`
  
# + module: pyppl.templates.template_pyppl
  
This template engine is borrowed from Templite  
The code is here: https://github.com/aosabook/500lines/blob/master/template-engine/code/templite.py  
Author: Ned Batchelder  
Project: Template engine  
Requirements: Python  
  
Modified by: pwwang  
Functions added:  
- support elif, else  
- support for dict: for k,v in dict.items()  
- support [] to get element from list or dict.  
- support multivariables in expression:  
{{d1,d2|concate}}  
{&#39;concate&#39;: lambda x,y: x+y}  
  
##   class: `TemplatePyPPLLine`
  
Line of compiled code  
  
### method: `__init__ (self, line, src, indent)`
  
Constructor of line  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ (self)`
  
##   class: `TemplatePyPPLRenderError`
  
Failed to render a template  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, stack, src)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `TemplatePyPPL`
  
Built-in template wrapper.  
  
### method: `__init__ (self, source, **envs)`
  
Initiate the engine with source and envs  

- **params:**  
`source`: The souce text  
`envs`: The env data  
  
### method: `__repr__ (self)`
  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ (self)`
  
### method: `_render (self, data)`
  
Render the template  

- **params:**  
`data`: The data used for rendering  

- **returns:**  
The rendered string  
  
### method: `registerEnvs (self, **envs)`
  
### method: `render (self, data)`
  
##   class: `TemplatePyPPLSyntaxError`
  
Raised when a template has a syntax error.  
  
### method: `__getitem__ ()`
x.__getitem__(y) &lt;==&gt; x[y]  
### method: `__init__ (self, name, src, msg)`
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ ()`
x.__str__() &lt;==&gt; str(x)  
##   class: `TemplatePyPPLEngine`
A simple template renderer, for a nano-subset of Django syntax.  
Supported constructs are extended variable access::  
{{var.modifer.modifier|filter|filter}}  
loops::  
{% for var in list %}...{% endfor %}  
and ifs::  
{% if var %}...{% endif %}  
Comments are within curly-hash markers::  
{# This will be ignored #}  
Construct a Templite with the template text, then use `render` against a  
dictionary context to create a finished string::  
templite = Templite(&#39;&#39;&#39;  
&lt;h1&gt;Hello {{name|upper}}!&lt;/h1&gt;  
{% for topic in topics %}  
&lt;p&gt;You are interested in {{topic}}.&lt;/p&gt;  
{% endif %}  
&#39;&#39;&#39;,  
{&#39;upper&#39;: str.upper},  
)  
text = templite.render({  
&#39;name&#39;: &quot;Ned&quot;,  
&#39;topics&#39;: [&#39;Python&#39;, &#39;Geometry&#39;, &#39;Juggling&#39;],  
})  
  
### method: `__init__ (self, text, *contexts)`
  
Construct a Templite with the given `text`.  
`contexts` are dictionaries of values to use for future renderings.  
These are good for filters and global values.  

- **params:**  
`text`: The template text  
`contexts`: The contexts used to render.  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ (self)`
  
Stringize the engine.  

- **returns:**  
The string of the stringized engine.  
  
### staticmethod: `_do_dots (value, *dots)`
  
Evaluate dotted expressions at runtime.  

- **params:**  
`value`: The value  
`dots`:  The set of dots to do one after another  

- **returns:**  
The value after dots being done  
  
### method: `_exprCode (self, expr, src)`
  
Generate a Python expression for `expr`.  

- **params:**  
`expr`: The expression  
`src`:  The source of the expression  

- **returns:**  
The code after the expression being parsed.  
  
### method: `_parseComments (self, token, src)`
  
### method: `_parseExpression (self, token, src)`
  
### method: `_parseLiteral (self, tokenlines, src)`
  
### method: `_parseTag (self, token, src, ops_stack)`
  
### staticmethod: `_variable (name, src, vars_set)`
  
Track that `name` is used as a variable.  
Adds the name to `vars_set`, a set of variable names.  
Raises an syntax error if `name` is not a valid name.  

- **params:**  
`name`: The name of the variable  
`src`:  The source of the variable  
`vars_set`: The variable set  
  
### method: `flushOutput (self)`
  
Force `self.buffered` to the code builder.  

- **params:**  
`code`: The code builder  
  
### method: `render (self, context)`
  
Render this template by applying it to `context`.  

- **params:**  
`context`: a dictionary of values to use in this rendering.  

- **returns:**  
The rendered string  
  
##   class: `TemplatePyPPLCodeBuilder`
  
Build source code conveniently.  
  
### method: `__init__ (self, envs, indent)`
  
Constructor of code builder  

- **params:**  
indent: The initial indent level  
  
### method: `__repr__ ()`
x.__repr__() &lt;==&gt; repr(x)  
### method: `__setattr__ ()`
x.__setattr__(&#39;name&#39;, value) &lt;==&gt; x.name = value  
### method: `__str__ (self)`
  
Concatnate of the codes  

- **returns:**  
The concatnated string  
  
### method: `_nlines (self)`
  
Get the number of lines in the builder  

- **returns:**  
The number of lines.  
  
### method: `addLine (self, line, src)`
  
Add a line of source to the code.  
Indentation and newline will be added for you, don&#39;t provide them.  

- **params:**  
line: The line to add  
  
### method: `addSection (self)`
  
Add a section, a sub-CodeBuilder.  

- **returns:**  
The section added.  
  
### method: `dedent (self)`
  
Decrease the current indent for following lines.  
  
### method: `getGlobals (self)`
  
Execute the code, and return a dict of globals it defines.  
  
### method: `indent (self)`
  
Increase the current indent for following lines.  
  
### method: `lineByNo (self, lineno)`
  
Get the line by line number  

- **params:**  
`lineno`: The line number  

- **returns:**  
The TemplatePyPPLLine object at `lineno`.  
  
# + module: pyppl.utils
  
A set of utitities for PyPPL  
  
##   function: `uid (s, l, alphabet)`
  
Calculate a short uid based on a string.  
Safe enough, tested on 1000000 32-char strings, no repeated uid found.  
This is used to calcuate a uid for a process  

- **params:**  
`s`: the base string  
`l`: the length of the uid  
`alphabet`: the charset used to generate the uid  

- **returns:**  
The uid  
  
##   function: `reduce (func, vec)`
  
Python2 and Python3 compatible reduce  

- **params:**  
`func`: The reduce function  
`vec`: The list to be reduced  

- **returns:**  
The reduced value  
  
##   function: `funcsig (func)`
  
Get the signature of a function  
Try to get the source first, if failed, try to get its name, otherwise return None  

- **params:**  
`func`: The function  

- **returns:**  
The signature  
  
##   function: `alwaysList (data)`
  
Convert a string or a list with element  

- **params:**  
`data`: the data to be converted  

- **examples:**  
```python  
data = [&quot;a, b, c&quot;, &quot;d&quot;]  
ret  = alwaysList (data)  
# ret == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]  
</pre></div></p>
<ul>
<li><strong>returns:</strong><br />
The split list  </li>
</ul>
<h3 id="function-formatsecs-seconds">function: <code>formatSecs (seconds)</code></h3>
<p>Format a time duration  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>seconds</code>: the time duration in seconds  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The formated string.<br />
For example: "01:01:01.001" stands for 1 hour 1 min 1 sec and 1 minisec.  </p>
</li>
</ul>
<h3 id="function-split-s-delimter-trim">function: <code>split (s, delimter, trim)</code></h3>
<p>Split a string using a single-character delimter  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>s</code>: the string<br />
<code>delimter</code>: the single-character delimter<br />
<code>trim</code>: whether to trim each part. Default: True  </p>
</li>
<li>
<p><strong>examples:</strong><br />
<div class="highlight"><pre><span></span><span class="n">ret</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;a,b&#39;,c&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>  
<span class="c1"># ret == [&quot;&#39;a,b&#39;&quot;, &quot;c&quot;]  </span>
<span class="c1"># &#39;,&#39; inside quotes will be recognized.  </span>
</pre></div></p>
</li>
<li>
<p><strong>returns:</strong><br />
The list of substrings  </p>
</li>
</ul>
<h3 id="function-brieflist-l">function: <code>briefList (l)</code></h3>
<p>Briefly show an integer list, combine the continuous numbers.  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>l</code>: The list  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The string to show for the briefed list.  </p>
</li>
</ul>
<h3 id="class-box">class: <code>Box</code></h3>
<p>Allow dot operation for OrderedDict  </p>
<h4 id="method-_ordereddict__update-args-kwds">method: <code>_OrderedDict__update (*args, **kwds)</code></h4>
<p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.<br />
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]<br />
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v<br />
In either case, this is followed by: for k, v in F.items(): D[k] = v  </p>
<h4 id="method-__cmp__">method: <code>__cmp__ ()</code></h4>
<p>x.<strong>cmp</strong>(y) &lt;==&gt; cmp(x,y)  </p>
<h4 id="method-__contains__">method: <code>__contains__ ()</code></h4>
<p>D.<strong>contains</strong>(k) -&gt; True if D has a key k, else False  </p>
<h4 id="method-__delitem__-self-key-dict_delitem">method: <code>__delitem__ (self, key, dict_delitem)</code></h4>
<p>od.<strong>delitem</strong>(y) &lt;==&gt; del od[y]  </p>
<h4 id="method-__ge__">method: <code>__ge__ ()</code></h4>
<p>x.<strong>ge</strong>(y) &lt;==&gt; x&gt;=y  </p>
<h4 id="method-__getattr__-self-name_3">method: <code>__getattr__ (self, name)</code></h4>
<h4 id="method-__getitem___1">method: <code>__getitem__ ()</code></h4>
<p>x.<strong>getitem</strong>(y) &lt;==&gt; x[y]  </p>
<h4 id="method-__gt__">method: <code>__gt__ ()</code></h4>
<p>x.<strong>gt</strong>(y) &lt;==&gt; x&gt;y  </p>
<h4 id="method-__init__-args-kwds">method: <code>__init__ (*args, **kwds)</code></h4>
<p>Initialize an ordered dictionary.  The signature is the same as<br />
regular dictionaries, but keyword arguments are not recommended because<br />
their insertion order is arbitrary.  </p>
<h4 id="method-__iter__-self">method: <code>__iter__ (self)</code></h4>
<p>od.<strong>iter</strong>() &lt;==&gt; iter(od)  </p>
<h4 id="method-__le__">method: <code>__le__ ()</code></h4>
<p>x.<strong>le</strong>(y) &lt;==&gt; x&lt;=y  </p>
<h4 id="method-__len__">method: <code>__len__ ()</code></h4>
<p>x.<strong>len</strong>() &lt;==&gt; len(x)  </p>
<h4 id="method-__lt__">method: <code>__lt__ ()</code></h4>
<p>x.<strong>lt</strong>(y) &lt;==&gt; x&lt;y  </p>
<h4 id="method-__repr__-self-_repr_running">method: <code>__repr__ (self, _repr_running)</code></h4>
<p>od.<strong>repr</strong>() &lt;==&gt; repr(od)  </p>
<h4 id="method-__reversed__-self">method: <code>__reversed__ (self)</code></h4>
<p>od.<strong>reversed</strong>() &lt;==&gt; reversed(od)  </p>
<h4 id="method-__setattr__-self-name-val">method: <code>__setattr__ (self, name, val)</code></h4>
<h4 id="method-__setitem__-self-key-value-dict_setitem">method: <code>__setitem__ (self, key, value, dict_setitem)</code></h4>
<p>od.<strong>setitem</strong>(i, y) &lt;==&gt; od[i]=y  </p>
<h4 id="method-__str___5">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h4 id="method-clear-self">method: <code>clear (self)</code></h4>
<p>od.clear() -&gt; None.  Remove all items from od.  </p>
<h4 id="method-copy-self">method: <code>copy (self)</code></h4>
<p>od.copy() -&gt; a shallow copy of od  </p>
<h4 id="method-fromkeys-cls-iterable-value">method: <code>fromkeys (cls, iterable, value)</code></h4>
<p>OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.<br />
If not specified, the value defaults to None.  </p>
<h4 id="method-get">method: <code>get ()</code></h4>
<p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.  </p>
<h4 id="method-has_key">method: <code>has_key ()</code></h4>
<p>D.has_key(k) -&gt; True if D has a key k, else False  </p>
<h4 id="method-items-self">method: <code>items (self)</code></h4>
<p>od.items() -&gt; list of (key, value) pairs in od  </p>
<h4 id="method-iteritems-self">method: <code>iteritems (self)</code></h4>
<p>od.iteritems -&gt; an iterator over the (key, value) pairs in od  </p>
<h4 id="method-iterkeys-self">method: <code>iterkeys (self)</code></h4>
<p>od.iterkeys() -&gt; an iterator over the keys in od  </p>
<h4 id="method-itervalues-self">method: <code>itervalues (self)</code></h4>
<p>od.itervalues -&gt; an iterator over the values in od  </p>
<h4 id="method-keys-self">method: <code>keys (self)</code></h4>
<p>od.keys() -&gt; list of keys in od  </p>
<h4 id="method-pop-self-key-default">method: <code>pop (self, key, default)</code></h4>
<p>od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding<br />
value.  If key is not found, d is returned if given, otherwise KeyError<br />
is raised.  </p>
<h4 id="method-popitem-self-last">method: <code>popitem (self, last)</code></h4>
<p>od.popitem() -&gt; (k, v), return and remove a (key, value) pair.<br />
Pairs are returned in LIFO order if last is true or FIFO order if false.  </p>
<h4 id="method-setdefault-self-key-default">method: <code>setdefault (self, key, default)</code></h4>
<p>od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od  </p>
<h4 id="method-update-args-kwds">method: <code>update (*args, **kwds)</code></h4>
<p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.<br />
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]<br />
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v<br />
In either case, this is followed by: for k, v in F.items(): D[k] = v  </p>
<h4 id="method-values-self">method: <code>values (self)</code></h4>
<p>od.values() -&gt; list of values in od  </p>
<h4 id="method-viewitems-self">method: <code>viewitems (self)</code></h4>
<p>od.viewitems() -&gt; a set-like object providing a view on od's items  </p>
<h4 id="method-viewkeys-self">method: <code>viewkeys (self)</code></h4>
<p>od.viewkeys() -&gt; a set-like object providing a view on od's keys  </p>
<h4 id="method-viewvalues-self">method: <code>viewvalues (self)</code></h4>
<p>od.viewvalues() -&gt; an object providing a view on od's values  </p>
<h3 id="function-map-func-vec">function: <code>map (func, vec)</code></h3>
<p>Python2 and Python3 compatible map  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>func</code>: The map function<br />
<code>vec</code>: The list to be maped  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The maped list  </p>
</li>
</ul>
<h3 id="function-varname-maxline-incldot">function: <code>varname (maxline, incldot)</code></h3>
<p>Get the variable name for ini  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>maxline</code>: The max number of lines to retrive. Default: 20<br />
<code>incldot</code>: Whether include dot in the variable name. Default: False  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The variable name  </p>
</li>
</ul>
<h3 id="function-filter-func-vec">function: <code>filter (func, vec)</code></h3>
<p>Python2 and Python3 compatible filter  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>func</code>: The filter function<br />
<code>vec</code>:  The list to be filtered  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The filtered list  </p>
</li>
</ul>
<h3 id="function-dictupdate-origdict-newdict">function: <code>dictUpdate (origDict, newDict)</code></h3>
<p>Update a dictionary recursively.  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>origDict</code>: The original dictionary<br />
<code>newDict</code>:  The new dictionary  </p>
</li>
<li>
<p><strong>examples:</strong><br />
<div class="highlight"><pre><span></span><span class="n">od1</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">}}}</span>  
<span class="n">od2</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="ow">in</span> <span class="n">od1</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>  
<span class="n">nd</span>  <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}}</span>  
<span class="n">od1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>  
<span class="c1"># od1 == {&quot;a&quot;: {&quot;b&quot;: {&quot;d&quot;: 2}}}, od1[&quot;a&quot;][&quot;b&quot;] is lost  </span>
<span class="n">dictUpdate</span><span class="p">(</span><span class="n">od2</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>  
<span class="c1"># od2 == {&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 1, &quot;d&quot;: 2}}}  </span>
</pre></div></p>
</li>
</ul>
<h3 id="function-range-i-args-kwargs">function: <code>range (i, *args, **kwargs)</code></h3>
<p>Convert a range to list, because in python3, range is not a list  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>r</code>: the range data  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The converted list  </p>
</li>
</ul>
<h3 id="function-asstr-s-encoding">function: <code>asStr (s, encoding)</code></h3>
<p>Convert everything (str, unicode, bytes) to str with python2, python3 compatiblity  </p>
<h2 id="module-pypplutilsbox">+ module: pyppl.utils.box</h2>
<h3 id="class-box_1">class: <code>Box</code></h3>
<p>Allow dot operation for OrderedDict  </p>
<h4 id="method-_ordereddict__update-args-kwds_1">method: <code>_OrderedDict__update (*args, **kwds)</code></h4>
<p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.<br />
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]<br />
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v<br />
In either case, this is followed by: for k, v in F.items(): D[k] = v  </p>
<h4 id="method-__cmp___1">method: <code>__cmp__ ()</code></h4>
<p>x.<strong>cmp</strong>(y) &lt;==&gt; cmp(x,y)  </p>
<h4 id="method-__contains___1">method: <code>__contains__ ()</code></h4>
<p>D.<strong>contains</strong>(k) -&gt; True if D has a key k, else False  </p>
<h4 id="method-__delitem__-self-key-dict_delitem_1">method: <code>__delitem__ (self, key, dict_delitem)</code></h4>
<p>od.<strong>delitem</strong>(y) &lt;==&gt; del od[y]  </p>
<h4 id="method-__ge___1">method: <code>__ge__ ()</code></h4>
<p>x.<strong>ge</strong>(y) &lt;==&gt; x&gt;=y  </p>
<h4 id="method-__getattr__-self-name_4">method: <code>__getattr__ (self, name)</code></h4>
<h4 id="method-__getitem___2">method: <code>__getitem__ ()</code></h4>
<p>x.<strong>getitem</strong>(y) &lt;==&gt; x[y]  </p>
<h4 id="method-__gt___1">method: <code>__gt__ ()</code></h4>
<p>x.<strong>gt</strong>(y) &lt;==&gt; x&gt;y  </p>
<h4 id="method-__init__-args-kwds_1">method: <code>__init__ (*args, **kwds)</code></h4>
<p>Initialize an ordered dictionary.  The signature is the same as<br />
regular dictionaries, but keyword arguments are not recommended because<br />
their insertion order is arbitrary.  </p>
<h4 id="method-__iter__-self_1">method: <code>__iter__ (self)</code></h4>
<p>od.<strong>iter</strong>() &lt;==&gt; iter(od)  </p>
<h4 id="method-__le___1">method: <code>__le__ ()</code></h4>
<p>x.<strong>le</strong>(y) &lt;==&gt; x&lt;=y  </p>
<h4 id="method-__len___1">method: <code>__len__ ()</code></h4>
<p>x.<strong>len</strong>() &lt;==&gt; len(x)  </p>
<h4 id="method-__lt___1">method: <code>__lt__ ()</code></h4>
<p>x.<strong>lt</strong>(y) &lt;==&gt; x&lt;y  </p>
<h4 id="method-__repr__-self-_repr_running_1">method: <code>__repr__ (self, _repr_running)</code></h4>
<p>od.<strong>repr</strong>() &lt;==&gt; repr(od)  </p>
<h4 id="method-__reversed__-self_1">method: <code>__reversed__ (self)</code></h4>
<p>od.<strong>reversed</strong>() &lt;==&gt; reversed(od)  </p>
<h4 id="method-__setattr__-self-name-val_1">method: <code>__setattr__ (self, name, val)</code></h4>
<h4 id="method-__setitem__-self-key-value-dict_setitem_1">method: <code>__setitem__ (self, key, value, dict_setitem)</code></h4>
<p>od.<strong>setitem</strong>(i, y) &lt;==&gt; od[i]=y  </p>
<h4 id="method-__str___6">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h4 id="method-clear-self_1">method: <code>clear (self)</code></h4>
<p>od.clear() -&gt; None.  Remove all items from od.  </p>
<h4 id="method-copy-self_1">method: <code>copy (self)</code></h4>
<p>od.copy() -&gt; a shallow copy of od  </p>
<h4 id="method-fromkeys-cls-iterable-value_1">method: <code>fromkeys (cls, iterable, value)</code></h4>
<p>OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.<br />
If not specified, the value defaults to None.  </p>
<h4 id="method-get_1">method: <code>get ()</code></h4>
<p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.  </p>
<h4 id="method-has_key_1">method: <code>has_key ()</code></h4>
<p>D.has_key(k) -&gt; True if D has a key k, else False  </p>
<h4 id="method-items-self_1">method: <code>items (self)</code></h4>
<p>od.items() -&gt; list of (key, value) pairs in od  </p>
<h4 id="method-iteritems-self_1">method: <code>iteritems (self)</code></h4>
<p>od.iteritems -&gt; an iterator over the (key, value) pairs in od  </p>
<h4 id="method-iterkeys-self_1">method: <code>iterkeys (self)</code></h4>
<p>od.iterkeys() -&gt; an iterator over the keys in od  </p>
<h4 id="method-itervalues-self_1">method: <code>itervalues (self)</code></h4>
<p>od.itervalues -&gt; an iterator over the values in od  </p>
<h4 id="method-keys-self_1">method: <code>keys (self)</code></h4>
<p>od.keys() -&gt; list of keys in od  </p>
<h4 id="method-pop-self-key-default_1">method: <code>pop (self, key, default)</code></h4>
<p>od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding<br />
value.  If key is not found, d is returned if given, otherwise KeyError<br />
is raised.  </p>
<h4 id="method-popitem-self-last_1">method: <code>popitem (self, last)</code></h4>
<p>od.popitem() -&gt; (k, v), return and remove a (key, value) pair.<br />
Pairs are returned in LIFO order if last is true or FIFO order if false.  </p>
<h4 id="method-setdefault-self-key-default_1">method: <code>setdefault (self, key, default)</code></h4>
<p>od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od  </p>
<h4 id="method-update-args-kwds_1">method: <code>update (*args, **kwds)</code></h4>
<p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.<br />
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]<br />
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v<br />
In either case, this is followed by: for k, v in F.items(): D[k] = v  </p>
<h4 id="method-values-self_1">method: <code>values (self)</code></h4>
<p>od.values() -&gt; list of values in od  </p>
<h4 id="method-viewitems-self_1">method: <code>viewitems (self)</code></h4>
<p>od.viewitems() -&gt; a set-like object providing a view on od's items  </p>
<h4 id="method-viewkeys-self_1">method: <code>viewkeys (self)</code></h4>
<p>od.viewkeys() -&gt; a set-like object providing a view on od's keys  </p>
<h4 id="method-viewvalues-self_1">method: <code>viewvalues (self)</code></h4>
<p>od.viewvalues() -&gt; an object providing a view on od's values  </p>
<h2 id="module-pypplutilscmd">+ module: pyppl.utils.cmd</h2>
<h3 id="function-run-cmd-bg-raiseexc-timeout-kwargs">function: <code>run (cmd, bg, raiseExc, timeout, **kwargs)</code></h3>
<p>A shortcut of <code>Command.run</code><br />
To chain another command, you can do:<br />
<code>run('seq 1 3', bg = True).pipe('grep 1')</code>  </p>
<ul>
<li><strong>params:</strong><br />
<code>cmd</code>     : The command, could be a string or a list<br />
<code>bg</code>      : Run in background or not. Default: <code>False</code>  </li>
<li>
<p>If it is <code>True</code>, <code>rc</code> and <code>stdout/stderr</code> will be default (no value retrieved).<br />
<code>raiseExc</code>: raise the expcetion or not<br />
<code>**kwargs</code>: other arguments for <code>Popen</code>  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The <code>Command</code> instance  </p>
</li>
</ul>
<h3 id="class-cmd">class: <code>Cmd</code></h3>
<p>A command (subprocess) wapper  </p>
<h4 id="method-__init__-self-cmd-raiseexc-timeout-kwargs">method: <code>__init__ (self, cmd, raiseExc, timeout, **kwargs)</code></h4>
<p>Constructor  </p>
<ul>
<li><strong>params:</strong><br />
<code>cmd</code>     : The command, could be a string or a list<br />
<code>raiseExc</code>: raise the expcetion or not<br />
<code>**kwargs</code>: other arguments for <code>Popen</code>  </li>
</ul>
<h4 id="method-__repr__-self_1">method: <code>__repr__ (self)</code></h4>
<h4 id="method-__setattr___2">method: <code>__setattr__ ()</code></h4>
<p>x.<strong>setattr</strong>('name', value) &lt;==&gt; x.name = value  </p>
<h4 id="method-__str___7">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h4 id="method-pipe-self-cmd-kwargs">method: <code>pipe (self, cmd, **kwargs)</code></h4>
<p>Pipe another command  </p>
<ul>
<li>
<p><strong>examples:</strong><br />
<div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">Command</span><span class="p">(</span><span class="s1">&#39;seq 1 3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s1">&#39;grep 1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  
<span class="n">c</span><span class="o">.</span><span class="n">stdout</span> <span class="o">==</span> <span class="s1">&#39;1  </span>
<span class="s1">&#39;  </span>
</pre></div></p>
</li>
<li>
<p><strong>params:</strong><br />
<code>cmd</code>: The other command<br />
<code>**kwargs</code>: Other arguments for <code>Popen</code> for the other command  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>Command</code> instance of the other command  </p>
</li>
</ul>
<h4 id="method-run-self-bg">method: <code>run (self, bg)</code></h4>
<p>Wait for the command to run  </p>
<ul>
<li><strong>params:</strong><br />
<code>bg</code>: Run in background or not. Default: <code>False</code>  </li>
<li>
<p>If it is <code>True</code>, <code>rc</code> and <code>stdout/stderr</code> will be default (no value retrieved).  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>self</code>  </p>
</li>
</ul>
<h2 id="module-pypplutilsparallel">+ module: pyppl.utils.parallel</h2>
<h3 id="function-run-func-args-nthread-backend-raiseexc">function: <code>run (func, args, nthread, backend, raiseExc)</code></h3>
<p>A shortcut of <code>Parallel.run</code>  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>func</code>    : The function to run<br />
<code>args</code>    : The arguments for the function, should be a <code>list</code> with <code>tuple</code>s<br />
<code>nthread</code> : Number of jobs to run simultaneously. Default: <code>1</code><br />
<code>backend</code> : The backend, either <code>process</code> (default) or <code>thread</code><br />
<code>raiseExc</code>: Whether raise exception or not. Default: <code>True</code>  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The merged results from each job.  </p>
</li>
</ul>
<h3 id="class-parallel">class: <code>Parallel</code></h3>
<p>A parallel runner  </p>
<h4 id="method-__init__-self-nthread-backend-raiseexc">method: <code>__init__ (self, nthread, backend, raiseExc)</code></h4>
<p>Constructor  </p>
<ul>
<li><strong>params:</strong><br />
<code>nthread</code> : Number of jobs to run simultaneously. Default: <code>1</code><br />
<code>backend</code> : The backend, either <code>process</code> (default) or <code>thread</code><br />
<code>raiseExc</code>: Whether raise exception or not. Default: <code>True</code>  </li>
</ul>
<h4 id="method-__repr___4">method: <code>__repr__ ()</code></h4>
<p>x.<strong>repr</strong>() &lt;==&gt; repr(x)  </p>
<h4 id="method-__setattr___3">method: <code>__setattr__ ()</code></h4>
<p>x.<strong>setattr</strong>('name', value) &lt;==&gt; x.name = value  </p>
<h4 id="method-__str___8">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h4 id="method-run-self-func-args">method: <code>run (self, func, args)</code></h4>
<p>Run parallel jobs  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>func</code>    : The function to run<br />
<code>args</code>    : The arguments for the function, should be a <code>list</code> with <code>tuple</code>s<br />
<code>nthread</code> : Number of jobs to run simultaneously. Default: <code>1</code><br />
<code>backend</code> : The backend, either <code>process</code> (default) or <code>thread</code><br />
<code>raiseExc</code>: Whether raise exception or not. Default: <code>True</code>  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The merged results from each job.  </p>
</li>
</ul>
<h2 id="module-pypplutilsps">+ module: pyppl.utils.ps</h2>
<h3 id="function-exists-pid">function: <code>exists (pid)</code></h3>
<p>Check whether pid exists in the current process table.<br />
From https://github.com/kennethreitz/delegator.py/blob/master/delegator.py  </p>
<h3 id="class-cmd_1">class: <code>Cmd</code></h3>
<p>A command (subprocess) wapper  </p>
<h4 id="method-__init__-self-cmd-raiseexc-timeout-kwargs_1">method: <code>__init__ (self, cmd, raiseExc, timeout, **kwargs)</code></h4>
<p>Constructor  </p>
<ul>
<li><strong>params:</strong><br />
<code>cmd</code>     : The command, could be a string or a list<br />
<code>raiseExc</code>: raise the expcetion or not<br />
<code>**kwargs</code>: other arguments for <code>Popen</code>  </li>
</ul>
<h4 id="method-__repr__-self_2">method: <code>__repr__ (self)</code></h4>
<h4 id="method-__setattr___4">method: <code>__setattr__ ()</code></h4>
<p>x.<strong>setattr</strong>('name', value) &lt;==&gt; x.name = value  </p>
<h4 id="method-__str___9">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h4 id="method-pipe-self-cmd-kwargs_1">method: <code>pipe (self, cmd, **kwargs)</code></h4>
<p>Pipe another command  </p>
<ul>
<li>
<p><strong>examples:</strong><br />
<div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">Command</span><span class="p">(</span><span class="s1">&#39;seq 1 3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s1">&#39;grep 1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  
<span class="n">c</span><span class="o">.</span><span class="n">stdout</span> <span class="o">==</span> <span class="s1">&#39;1  </span>
<span class="s1">&#39;  </span>
</pre></div></p>
</li>
<li>
<p><strong>params:</strong><br />
<code>cmd</code>: The other command<br />
<code>**kwargs</code>: Other arguments for <code>Popen</code> for the other command  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>Command</code> instance of the other command  </p>
</li>
</ul>
<h4 id="method-run-self-bg_1">method: <code>run (self, bg)</code></h4>
<p>Wait for the command to run  </p>
<ul>
<li><strong>params:</strong><br />
<code>bg</code>: Run in background or not. Default: <code>False</code>  </li>
<li>
<p>If it is <code>True</code>, <code>rc</code> and <code>stdout/stderr</code> will be default (no value retrieved).  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>self</code>  </p>
</li>
</ul>
<h3 id="function-child-pid-pidlist">function: <code>child (pid, pidlist)</code></h3>
<p>Direct children  </p>
<h2 id="module-pypplutilssafefs">+ module: pyppl.utils.safefs</h2>
<h3 id="function-copyfile-src-dst">function: <code>copyfile (src, dst)</code></h3>
<p>Copy data from src to dst  </p>
<h3 id="function-exists-filepath-callback">function: <code>exists (filepath, callback)</code></h3>
<p>A shortcut of <code>SafeFs.exists</code>  </p>
<ul>
<li><strong>params:</strong><br />
<code>filepath</code>: The filepath<br />
<code>callback</code>: The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if the file exists else <code>False</code>  </p>
</li>
</ul>
<h3 id="function-move-file1-file2-overwrite-callback">function: <code>move (file1, file2, overwrite, callback)</code></h3>
<p>A shortcut of <code>SafeFs.move</code>  </p>
<ul>
<li><strong>params:</strong><br />
<code>file1</code>    : File 1<br />
<code>file2</code>    : File 2<br />
<code>overwrite</code>: Whether overwrite file 2. Default: <code>True</code><br />
<code>callback</code> : The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h3 id="function-gz-file1-file2-overwrite-callback">function: <code>gz (file1, file2, overwrite, callback)</code></h3>
<p>A shortcut of <code>SafeFs.gz</code>  </p>
<ul>
<li><strong>params:</strong><br />
<code>file1</code>    : File 1<br />
<code>file2</code>    : File 2<br />
<code>overwrite</code>: Whether overwrite file 2. Default: <code>True</code><br />
<code>callback</code> : The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h3 id="function-walk-top-topdown-onerror-followlinks">function: <code>walk (top, topdown, onerror, followlinks)</code></h3>
<p>Directory tree generator.  </p>
<p>For each directory in the directory tree rooted at top (including top<br />
itself, but excluding '.' and '..'), yields a 3-tuple  </p>
<p>dirpath, dirnames, filenames  </p>
<p>dirpath is a string, the path to the directory.  dirnames is a list of<br />
the names of the subdirectories in dirpath (excluding '.' and '..').<br />
filenames is a list of the names of the non-directory files in dirpath.<br />
Note that the names in the lists are just names, with no path components.<br />
To get a full path (which begins with top) to a file or directory in<br />
dirpath, do os.path.join(dirpath, name).  </p>
<p>If optional arg 'topdown' is true or not specified, the triple for a<br />
directory is generated before the triples for any of its subdirectories<br />
(directories are generated top down).  If topdown is false, the triple<br />
for a directory is generated after the triples for all of its<br />
subdirectories (directories are generated bottom up).  </p>
<p>When topdown is true, the caller can modify the dirnames list in-place<br />
(e.g., via del or slice assignment), and walk will only recurse into the<br />
subdirectories whose names remain in dirnames; this can be used to prune the<br />
search, or to impose a specific order of visiting.  Modifying dirnames when<br />
topdown is false is ineffective, since the directories in dirnames have<br />
already been generated by the time dirnames itself is generated. No matter<br />
the value of topdown, the list of subdirectories is retrieved before the<br />
tuples for the directory and its subdirectories are generated.  </p>
<p>By default errors from the os.listdir() call are ignored.  If<br />
optional arg 'onerror' is specified, it should be a function; it<br />
will be called with one argument, an os.error instance.  It can<br />
report the error to continue with the walk, or raise the exception<br />
to abort the walk.  Note that the filename is available as the<br />
filename attribute of the exception object.  </p>
<p>By default, os.walk does not follow symbolic links to subdirectories on<br />
systems that support them.  In order to get this functionality, set the<br />
optional argument 'followlinks' to true.  </p>
<p>Caution:  if you pass a relative pathname for top, don't change the<br />
current working directory between resumptions of walk.  walk never<br />
changes the current directory, and assumes that the client doesn't<br />
either.  </p>
<p>Example:  </p>
<p>import os<br />
from os.path import join, getsize<br />
for root, dirs, files in os.walk('python/Lib/email'):<br />
print root, "consumes",<br />
print sum([getsize(join(root, name)) for name in files]),<br />
print "bytes in", len(files), "non-directory files"<br />
if 'CVS' in dirs:<br />
dirs.remove('CVS')  # don't visit CVS directories  </p>
<h3 id="class-safefs">class: <code>SafeFs</code></h3>
<p>A thread-safe file system  </p>
<ul>
<li><strong>static variables:</strong>  </li>
</ul>
<p><code>TMPDIR</code>: The default temporary directory to store lock files  </p>
<h2 id="file-types">file types</h2>
<p><code>FILETYPE_UNKNOWN</code>  : Unknown file type<br />
<code>FILETYPE_NOENT</code>    : File does not exist<br />
<code>FILETYPE_NOENTLINK</code>: A dead link (a link links to a non-existent file.<br />
<code>FILETYPE_FILE</code>     : A regular file<br />
<code>FILETYPE_FILELINK</code> : A link to a regular file<br />
<code>FILETYPE_DIR</code>      : A regular directory<br />
<code>FILETYPE_DIRLINK</code>  : A link to a regular directory  </p>
<h2 id="relation-of-two-files">relation of two files</h2>
<p><code>FILES_DIFF_BOTHNOENT</code> : Two files are different and none of them exists<br />
<code>FILES_DIFF_NOENT1</code>    : Two files are different but file1 does not exists<br />
<code>FILES_DIFF_NOENT2</code>    : Two files are different but file2 does not exists<br />
<code>FILES_DIFF_BOTHENT</code>   : Two files are different and both of them exist<br />
<code>FILES_SAME_STRNOENT</code>  : Two files are the same string and it does not exist<br />
<code>FILES_SAME_STRENT</code>    : Two files are the same string and it exists<br />
<code>FILES_SAME_BOTHLINKS</code> : Two files link to one file<br />
<code>FILES_SAME_BOTHLINKS1</code>: File1 links to file2, file2 links to a regular file<br />
<code>FILES_SAME_BOTHLINKS2</code>: File2 links to file1, file1 links to a regular file<br />
<code>FILES_SAME_REAL1</code>     : File2 links to file1, which a regular file<br />
<code>FILES_SAME_REAL2</code>     : File1 links to file2, which a regular file  </p>
<p><code>LOCK</code>: A global lock ensures the locks are locked at the same time  </p>
<h4 id="method-__init__-self-file1-file2-tmpdir">method: <code>__init__ (self, file1, file2, tmpdir)</code></h4>
<p>Constructor  </p>
<ul>
<li><strong>params:</strong><br />
<code>file1</code>:  File 1<br />
<code>file2</code>:  File 2. Default: <code>None</code><br />
<code>tmpdir</code>: The temporary directory used to store lock files. Default: <code>None</code> (<code>SafeFs.TMPDIR</code>)  </li>
</ul>
<h4 id="method-__repr___5">method: <code>__repr__ ()</code></h4>
<p>x.<strong>repr</strong>() &lt;==&gt; repr(x)  </p>
<h4 id="method-__setattr___5">method: <code>__setattr__ ()</code></h4>
<p>x.<strong>setattr</strong>('name', value) &lt;==&gt; x.name = value  </p>
<h4 id="method-__str___10">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h4 id="staticmethod-_copy-file1-file2-overwrite-filetype1-filetype2">staticmethod: <code>_copy (file1, file2, overwrite, filetype1, filetype2)</code></h4>
<p>Copy a file or a directory  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>file1</code>    : The source<br />
<code>file2</code>    : The destination<br />
<code>overwrite</code>: Overwrite the destination? Default: <code>True</code><br />
<code>filetype1</code>: The file type of file1<br />
<code>filetype2</code>: The file type of file2  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="staticmethod-_dirmtime-filepath">staticmethod: <code>_dirmtime (filepath)</code></h4>
<p>Get the modified time of a directory recursively  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>filepath</code>: The file path  </p>
</li>
<li>
<p><strong>return`:</strong><br />
The most recent modified time  </p>
</li>
</ul>
<h4 id="staticmethod-_exists-filepath-filetype">staticmethod: <code>_exists (filepath, filetype)</code></h4>
<p>Tell if a file exists  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>filepath</code>: The source<br />
<code>filetype</code>: The file type of file2  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if exists else <code>False</code>  </p>
</li>
</ul>
<h4 id="staticmethod-_filerel-file1-file2-filetype1-filetype2">staticmethod: <code>_filerel (file1, file2, filetype1, filetype2)</code></h4>
<p>Check the relations between file1 and file2.  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>file1</code>: The first file<br />
<code>file2</code>: The second file<br />
<code>filetype1</code>: The file type of file1<br />
<code>filetype2</code>: The file type of file2  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>SafeFs.FILES_DIFF_BOTHNOENT</code>: they are different for whatever reason.<br />
<code>SafeFs.FILES_DIFF_NOENT1</code>   : they are different for whatever reason.<br />
<code>SafeFs.FILES_DIFF_NOENT2</code>   : they are different for whatever reason.<br />
<code>SafeFs.FILES_DIFF_BOTHENT</code>  : they are different for whatever reason.<br />
<code>SafeFs.FILES_SAME_STRENT</code>   : they are the same string and the file exists.<br />
<code>SafeFs.FILES_SAME_STRNOENT</code> : they are the same string but the file doesn't exist.<br />
<code>SafeFs.FILES_SAME_BOTHLINKS</code>: both of them are links to the same file.<br />
<code>SafeFs.FILES_SAME_REAL1</code>    : file1 is the real file, file2 is a link to it.<br />
<code>SafeFs.FILES_SAME_REAL2</code>    : file2 is the real file, file1 is a link to it.  </p>
</li>
</ul>
<h4 id="staticmethod-_filetype-filepath">staticmethod: <code>_filetype (filepath)</code></h4>
<p>Get the file type  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>filepath</code>: The file path  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The file type (one of <code>SafeFs.FILETYPE_*</code>)  </p>
</li>
</ul>
<h4 id="staticmethod-_gz-file1-file2-overwrite-filetype1-filetype2">staticmethod: <code>_gz (file1, file2, overwrite, filetype1, filetype2)</code></h4>
<p>Gzip a file or tar gzip a directory  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>file1</code>    : The source<br />
<code>file2</code>    : The destination<br />
<code>overwrite</code>: Overwrite the destination? Default: <code>True</code><br />
<code>filetype1</code>: The file type of file1<br />
<code>filetype2</code>: The file type of file2  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="staticmethod-_link-file1-file2-overwrite-filetype1-filetype2">staticmethod: <code>_link (file1, file2, overwrite, filetype1, filetype2)</code></h4>
<p>Create a symbolic link for the given file  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>file1</code>    : The source<br />
<code>file2</code>    : The destination<br />
<code>overwrite</code>: Overwrite the destination? Default: <code>True</code><br />
<code>filetype1</code>: The file type of file1<br />
<code>filetype2</code>: The file type of file2  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-_lock-self-lock1-lock2">method: <code>_lock (self, lock1, lock2)</code></h4>
<p>Lock the file slots  </p>
<ul>
<li><strong>params:</strong><br />
<code>lock1</code>: Which slots to lock for file1  </li>
<li><code>both</code>: Both the file itself and the realpath of it (if it is a link)  </li>
<li><code>real</code>: Only the realpath of it  </li>
<li><code>self</code>: Just the file itself<br />
<code>lock2</code>: Which slots to lock for file2  </li>
</ul>
<h4 id="staticmethod-_lockfile-filepath-real-filetype-tmpdir">staticmethod: <code>_lockfile (filepath, real, filetype, tmpdir)</code></h4>
<p>Get the path of lockfile of a file  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>filepath</code>: The file<br />
<code>real</code>    : Use the filepath itself or the realpath (if filepath is a link). Default: <code>True</code><br />
<code>filetype</code>: The filetype, if not provided, will be fetched by <code>SafeFs._filetype</code><br />
<code>tmpdir</code>  : The tmpdir storing the lock files.  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The path of the lock file  </p>
</li>
</ul>
<h4 id="staticmethod-_move-file1-file2-overwrite-filetype1-filetype2">staticmethod: <code>_move (file1, file2, overwrite, filetype1, filetype2)</code></h4>
<p>Move a file  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>file1</code>    : The source<br />
<code>file2</code>    : The destination<br />
<code>overwrite</code>: Overwrite the destination? Default: <code>True</code><br />
<code>filetype1</code>: The file type of file1<br />
<code>filetype2</code>: The file type of file2  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="staticmethod-_remove-filepath-filetype">staticmethod: <code>_remove (filepath, filetype)</code></h4>
<p>Remove an entry  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>filepath</code>: The path of the entry<br />
<code>filetype</code>: The file type  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="staticmethod-_ungz-file1-file2-overwrite-filetype1-filetype2">staticmethod: <code>_ungz (file1, file2, overwrite, filetype1, filetype2)</code></h4>
<p>Decompress a gzip file or tar-gzip file  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>file1</code>    : The source<br />
<code>file2</code>    : The destination<br />
<code>overwrite</code>: Overwrite the destination? Default: <code>True</code><br />
<code>filetype1</code>: The file type of file1<br />
<code>filetype2</code>: The file type of file2  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-_unlock-self">method: <code>_unlock (self)</code></h4>
<p>Unlock the slots  </p>
<h4 id="staticmethod-basename-filepath">staticmethod: <code>basename (filepath)</code></h4>
<p>Get the basename of a file<br />
If it is a directory like '/a/b/c/', return <code>c</code>  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>filepath</code>: The file path  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The basename  </p>
</li>
</ul>
<h4 id="method-chmodx-self">method: <code>chmodX (self)</code></h4>
<p>Convert file1 to executable or add extract shebang to cmd line  </p>
<ul>
<li><strong>returns:</strong><br />
A list with or without the path of the interpreter as the first element and the script file as the last element  </li>
</ul>
<h4 id="method-copy-self-overwrite-callback">method: <code>copy (self, overwrite, callback)</code></h4>
<p>Copy file1 to file2 thread-safely  </p>
<ul>
<li><strong>params:</strong><br />
<code>overwrite</code>: Allow overwrting file2? Default: <code>True</code><br />
<code>callback</code>:  The callback. arguments:  </li>
<li><code>r</code> :  Whether the file exists  </li>
<li>
<p><code>fs</code>:  This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-exists-self-callback">method: <code>exists (self, callback)</code></h4>
<p>Tell if file1 exists thread-safely  </p>
<ul>
<li><strong>params:</strong><br />
<code>callback</code>: The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if exists else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-filesig-self-dirsig">method: <code>filesig (self, dirsig)</code></h4>
<p>Generate a signature for a file  </p>
<ul>
<li>
<p><strong>params:</strong><br />
<code>dirsig</code>: Whether expand the directory? Default: True  </p>
</li>
<li>
<p><strong>returns:</strong><br />
The signature  </p>
</li>
</ul>
<h4 id="staticmethod-flush-fd-lastmsg-end">staticmethod: <code>flush (fd, lastmsg, end)</code></h4>
<p>Flush a file descriptor  </p>
<ul>
<li><strong>params:</strong><br />
<code>fd</code>     : The file handler<br />
<code>lastmsg</code>: The remaining content of last flush<br />
<code>end</code>    : The file ends? Default: <code>False</code>  </li>
</ul>
<h4 id="method-gz-self-overwrite-callback">method: <code>gz (self, overwrite, callback)</code></h4>
<p>Gzip file1 (tar-gzip if file1 is a directory) to file2 in a thread-safe way  </p>
<ul>
<li><strong>params:</strong><br />
<code>overwrite</code>: Allow overwrting file2? Default: <code>True</code><br />
<code>callback</code>:  The callback. arguments:  </li>
<li><code>r</code> :  Whether the file exists  </li>
<li>
<p><code>fs</code>:  This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-link-self-overwrite-callback">method: <code>link (self, overwrite, callback)</code></h4>
<p>Link file1 to file2 thread-safely  </p>
<ul>
<li><strong>params:</strong><br />
<code>overwrite</code>: Allow overwrting file2? Default: <code>True</code><br />
<code>callback</code>:  The callback. arguments:  </li>
<li><code>r</code> :  Whether the file exists  </li>
<li>
<p><code>fs</code>:  This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-move-self-overwrite-callback">method: <code>move (self, overwrite, callback)</code></h4>
<p>Move file1 to file2 thread-safely  </p>
<ul>
<li><strong>params:</strong><br />
<code>overwrite</code>: Allow overwrting file2? Default: <code>True</code><br />
<code>callback</code>:  The callback. arguments:  </li>
<li><code>r</code> :  Whether the file exists  </li>
<li>
<p><code>fs</code>:  This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-movewithlink-self-overwrite-callback">method: <code>moveWithLink (self, overwrite, callback)</code></h4>
<p>Move file1 to file2 and link file2 to file1 in a thread-safe way  </p>
<ul>
<li><strong>params:</strong><br />
<code>overwrite</code>: Allow overwrting file2? Default: <code>True</code><br />
<code>callback</code>:  The callback. arguments:  </li>
<li><code>r</code> :  Whether the file exists  </li>
<li>
<p><code>fs</code>:  This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-remove-self-callback">method: <code>remove (self, callback)</code></h4>
<p>Remove file1 thread-safely  </p>
<ul>
<li><strong>params:</strong><br />
<code>callback</code>: The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-samefile-self-callback">method: <code>samefile (self, callback)</code></h4>
<p>Tell if file1 and file2 are the same file in a thread-safe way  </p>
<ul>
<li><strong>params:</strong><br />
<code>callback</code>: The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if they are the same file else <code>False</code>  </p>
</li>
</ul>
<h4 id="method-ungz-self-overwrite-callback">method: <code>ungz (self, overwrite, callback)</code></h4>
<p>Ungzip file1 (tar-ungzip if file1 tar-gzipped to file2 in a thread-safe way  </p>
<ul>
<li><strong>params:</strong><br />
<code>overwrite</code>: Allow overwrting file2? Default: <code>True</code><br />
<code>callback</code>:  The callback. arguments:  </li>
<li><code>r</code> :  Whether the file exists  </li>
<li>
<p><code>fs</code>:  This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h3 id="function-copytree-src-dst-symlinks-ignore">function: <code>copytree (src, dst, symlinks, ignore)</code></h3>
<p>Recursively copy a directory tree using copy2().  </p>
<p>The destination directory must not already exist.<br />
If exception(s) occur, an Error is raised with a list of reasons.  </p>
<p>If the optional symlinks flag is true, symbolic links in the<br />
source tree result in symbolic links in the destination tree; if<br />
it is false, the contents of the files pointed to by symbolic<br />
links are copied.  </p>
<p>The optional ignore argument is a callable. If given, it<br />
is called with the <code>src</code> parameter, which is the directory<br />
being visited by copytree(), and <code>names</code> which is the list of<br />
<code>src</code> contents, as returned by os.listdir():  </p>
<p>callable(src, names) -&gt; ignored_names  </p>
<p>Since copytree() is called recursively, the callable will be<br />
called once for each directory that is copied. It returns a<br />
list of names relative to the <code>src</code> directory that should<br />
not be copied.  </p>
<p>XXX Consider this example code rather than the ultimate tool.  </p>
<h3 id="function-copyfileobj-fsrc-fdst-length">function: <code>copyfileobj (fsrc, fdst, length)</code></h3>
<p>copy data from file-like object fsrc to file-like object fdst  </p>
<h3 id="class-chmoderror">class: <code>ChmodError</code></h3>
<p>OS system call failed.  </p>
<h4 id="method-__getitem___3">method: <code>__getitem__ ()</code></h4>
<p>x.<strong>getitem</strong>(y) &lt;==&gt; x[y]  </p>
<h4 id="method-__init__">method: <code>__init__ ()</code></h4>
<p>x.<strong>init</strong>(...) initializes x; see help(type(x)) for signature  </p>
<h4 id="method-__repr___6">method: <code>__repr__ ()</code></h4>
<p>x.<strong>repr</strong>() &lt;==&gt; repr(x)  </p>
<h4 id="method-__setattr___6">method: <code>__setattr__ ()</code></h4>
<p>x.<strong>setattr</strong>('name', value) &lt;==&gt; x.name = value  </p>
<h4 id="method-__str___11">method: <code>__str__ ()</code></h4>
<p>x.<strong>str</strong>() &lt;==&gt; str(x)  </p>
<h3 id="function-ungz-file1-file2-overwrite-callback">function: <code>ungz (file1, file2, overwrite, callback)</code></h3>
<p>A shortcut of <code>SafeFs.ungz</code>  </p>
<ul>
<li><strong>params:</strong><br />
<code>file1</code>    : File 1<br />
<code>file2</code>    : File 2<br />
<code>overwrite</code>: Whether overwrite file 2. Default: <code>True</code><br />
<code>callback</code> : The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h3 id="function-shmove-src-dst">function: <code>shmove (src, dst)</code></h3>
<p>Recursively move a file or directory to another location. This is<br />
similar to the Unix "mv" command.  </p>
<p>If the destination is a directory or a symlink to a directory, the source<br />
is moved inside the directory. The destination path must not already<br />
exist.  </p>
<p>If the destination already exists but is not a directory, it may be<br />
overwritten depending on os.rename() semantics.  </p>
<p>If the destination is on our current filesystem, then rename() is used.<br />
Otherwise, src is copied to the destination and then removed.<br />
A lot more could be done here...  A look at a mv.c shows a lot of<br />
the issues this implementation glosses over.  </p>
<h3 id="function-movewithlink-file1-file2-overwrite-callback">function: <code>moveWithLink (file1, file2, overwrite, callback)</code></h3>
<p>A shortcut of <code>SafeFs.moveWithLink</code>  </p>
<ul>
<li><strong>params:</strong><br />
<code>file1</code>    : File 1<br />
<code>file2</code>    : File 2<br />
<code>overwrite</code>: Whether overwrite file 2. Default: <code>True</code><br />
<code>callback</code> : The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h3 id="function-link-file1-file2-overwrite-callback">function: <code>link (file1, file2, overwrite, callback)</code></h3>
<p>A shortcut of <code>SafeFs.link</code>  </p>
<ul>
<li><strong>params:</strong><br />
<code>file1</code>    : File 1<br />
<code>file2</code>    : File 2<br />
<code>overwrite</code>: Whether overwrite file 2. Default: <code>True</code><br />
<code>callback</code> : The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h3 id="function-copy-file1-file2-overwrite-callback">function: <code>copy (file1, file2, overwrite, callback)</code></h3>
<p>A shortcut of <code>SafeFs.copy</code>  </p>
<ul>
<li><strong>params:</strong><br />
<code>file1</code>    : File 1<br />
<code>file2</code>    : File 2<br />
<code>overwrite</code>: Whether overwrite file 2. Default: <code>True</code><br />
<code>callback</code> : The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
<h3 id="function-lock">function: <code>Lock ()</code></h3>
<p>Returns a non-recursive lock object  </p>
<h3 id="function-remove-filepath-callback">function: <code>remove (filepath, callback)</code></h3>
<p>A shortcut of <code>SafeFs.remove</code>  </p>
<ul>
<li><strong>params:</strong><br />
<code>filepath</code>: The filepath<br />
<code>callback</code>: The callback. arguments:  </li>
<li><code>r</code> : Whether the file exists  </li>
<li>
<p><code>fs</code>: This instance  </p>
</li>
<li>
<p><strong>returns:</strong><br />
<code>True</code> if succeed else <code>False</code>  </p>
</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../faq/" class="btn btn-neutral float-right" title="FAQ">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../command-line-tool/" class="btn btn-neutral" title="Command line tool"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../command-line-tool/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../faq/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
